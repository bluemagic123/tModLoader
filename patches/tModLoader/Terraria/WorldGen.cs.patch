--- src/Terraria/Terraria/WorldGen.cs
+++ src/tModLoader/Terraria/WorldGen.cs
@@ -1,4 +_,5 @@
 using Microsoft.Xna.Framework;
+using Microsoft.Xna.Framework.Graphics;
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
@@ -24,6 +_,8 @@
 using Terraria.ObjectData;
 using Terraria.Utilities;
 using Terraria.WorldBuilding;
+using Terraria.ModLoader;
+using Terraria.ModLoader.IO;
 
 namespace Terraria
 {
@@ -470,7 +_,7 @@
 				}
 			}
 
-			private static bool Gemmable(int type) {
+			public static bool Gemmable(int type) {
 				if (type != 0 && type != 1 && type != 40 && type != 59 && type != 60 && type != 70 && type != 147)
 					return type == 161;
 
@@ -659,12 +_,18 @@
 		public delegate bool GetTreeFoliageDataMethod(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight);
 
 		public static TownRoomManager TownManager = new TownRoomManager();
-		private static int lAltarX;
+		public static int lAltarX;
-		private static int lAltarY;
+		public static int lAltarY;
-		private static Queue<Action<StructureMap>> _postGenActions = new Queue<Action<StructureMap>>();
+		public static Queue<Action<StructureMap>> _postGenActions = new Queue<Action<StructureMap>>();
 		public static int tileReframeCount;
 		public static bool noMapUpdate;
+		public static StructureMap structures;
+		public static double worldSurface;
 		public static double worldSurfaceLow;
+		public static double worldSurfaceHigh;
+		public static double rockLayer;
+		public static double rockLayerLow;
+		public static double rockLayerHigh;
 		public static int tLeft;
 		public static int tRight;
 		public static int tTop;
@@ -676,7 +_,7 @@
 		public static int ironBar = 22;
 		public static int silverBar = 21;
 		public static int goldBar = 19;
-		private const int NUM_SEASHELL_STYLES = 2;
+		public const int NUM_SEASHELL_STYLES = 2;
 		public static int treeBG1;
 		public static int treeBG2;
 		public static int treeBG3;
@@ -690,7 +_,7 @@
 		public static int oceanBG;
 		public static int mushroomBG;
 		public static int underworldBG;
-		private static ushort crackedType = 481;
+		public static ushort crackedType = 481;
 		public static int oceanDistance = 250;
 		public static int beachDistance = 380;
 		public static bool skipDesertTileCheck = false;
@@ -715,8 +_,8 @@
 		public static int totalX;
 		public static int totalD;
 		public static bool IsGeneratingHardMode;
-		private static Vector2[] heartPos = new Vector2[100];
+		public static Vector2[] heartPos = new Vector2[100];
-		private static int heartCount;
+		public static int heartCount;
 		public static int maxTreeShakes = 500;
 		public static int numTreeShakes = 0;
 		public static int[] treeShakeX = new int[maxTreeShakes];
@@ -739,15 +_,15 @@
 		public static bool worldCleared;
 		public static bool worldBackup;
 		public static bool loadBackup = false;
-		private static int lastMaxTilesX;
+		public static int lastMaxTilesX;
-		private static int lastMaxTilesY;
+		public static int lastMaxTilesY;
-		private static bool mergeUp;
+		public static bool mergeUp;
-		private static bool mergeDown;
+		public static bool mergeDown;
-		private static bool mergeLeft;
+		public static bool mergeLeft;
-		private static bool mergeRight;
+		public static bool mergeRight;
-		private static bool stopDrops;
+		public static bool stopDrops;
 		public static bool mudWall;
-		private static int grassSpread;
+		public static int grassSpread;
 		public static bool noLiquidCheck;
 		public static bool AllowedToSpreadInfections = true;
 		[ThreadStatic]
@@ -791,75 +_,75 @@
 		public static int[] dRoomX = new int[maxDRooms];
 		public static int[] dRoomY = new int[maxDRooms];
 		public static int[] dRoomSize = new int[maxDRooms];
-		private static bool[] dRoomTreasure = new bool[maxDRooms];
+		public static bool[] dRoomTreasure = new bool[maxDRooms];
-		private static int[] dRoomL = new int[maxDRooms];
+		public static int[] dRoomL = new int[maxDRooms];
-		private static int[] dRoomR = new int[maxDRooms];
+		public static int[] dRoomR = new int[maxDRooms];
-		private static int[] dRoomT = new int[maxDRooms];
+		public static int[] dRoomT = new int[maxDRooms];
-		private static int[] dRoomB = new int[maxDRooms];
+		public static int[] dRoomB = new int[maxDRooms];
-		private static int numDDoors;
+		public static int numDDoors;
-		private static int[] DDoorX = new int[500];
+		public static int[] DDoorX = new int[500];
-		private static int[] DDoorY = new int[500];
+		public static int[] DDoorY = new int[500];
-		private static int[] DDoorPos = new int[500];
+		public static int[] DDoorPos = new int[500];
-		private static int numDungeonPlatforms;
+		public static int numDungeonPlatforms;
-		private static int[] dungeonPlatformX = new int[500];
+		public static int[] dungeonPlatformX = new int[500];
-		private static int[] dungeonPlatformY = new int[500];
+		public static int[] dungeonPlatformY = new int[500];
-		private static bool generatedShadowKey;
+		public static bool generatedShadowKey;
-		private static int JungleItemCount;
+		public static int JungleItemCount;
-		private static int[] JChestX = new int[100];
+		public static int[] JChestX = new int[100];
-		private static int[] JChestY = new int[100];
+		public static int[] JChestY = new int[100];
-		private static int numJChests;
+		public static int numJChests;
 		public static int dEnteranceX;
 		public static bool dSurface;
-		private static double dxStrength1;
+		public static double dxStrength1;
-		private static double dyStrength1;
+		public static double dyStrength1;
-		private static double dxStrength2;
+		public static double dxStrength2;
-		private static double dyStrength2;
+		public static double dyStrength2;
-		private static int dMinX;
+		public static int dMinX;
-		private static int dMaxX;
+		public static int dMaxX;
-		private static int dMinY;
+		public static int dMinY;
-		private static int dMaxY;
+		public static int dMaxY;
-		private static int numIslandHouses;
+		public static int numIslandHouses;
-		private static int houseCount;
+		public static int houseCount;
-		private static bool[] skyLake = new bool[30];
+		public static bool[] skyLake = new bool[30];
-		private static int[] floatingIslandHouseX = new int[30];
+		public static int[] floatingIslandHouseX = new int[30];
-		private static int[] floatingIslandHouseY = new int[30];
+		public static int[] floatingIslandHouseY = new int[30];
-		private static int[] floatingIslandStyle = new int[30];
+		public static int[] floatingIslandStyle = new int[30];
-		private static int numMCaves;
+		public static int numMCaves;
-		private static int[] mCaveX = new int[30];
+		public static int[] mCaveX = new int[30];
-		private static int[] mCaveY = new int[30];
+		public static int[] mCaveY = new int[30];
 		public static int WorldGenParam_Evil = -1;
-		private static int maxTunnels = 50;
+		public static int maxTunnels = 50;
-		private static int numTunnels;
+		public static int numTunnels;
-		private static int[] tunnelX = new int[maxTunnels];
+		public static int[] tunnelX = new int[maxTunnels];
-		private static int maxOrePatch = 50;
+		public static int maxOrePatch = 50;
-		private static int numOrePatch;
+		public static int numOrePatch;
-		private static int[] orePatchX = new int[maxOrePatch];
+		public static int[] orePatchX = new int[maxOrePatch];
-		private static int maxOasis = 20;
+		public static int maxOasis = 20;
-		private static int numOasis = 0;
+		public static int numOasis = 0;
-		private static Vector2[] oasisPosition = new Vector2[maxOasis];
+		public static Vector2[] oasisPosition = new Vector2[maxOasis];
-		private static int[] oasisWidth = new int[maxOasis];
+		public static int[] oasisWidth = new int[maxOasis];
-		private static int oasisHeight = 20;
+		public static int oasisHeight = 20;
-		private static int maxMushroomBiomes = 50;
+		public static int maxMushroomBiomes = 50;
-		private static int numMushroomBiomes = 0;
+		public static int numMushroomBiomes = 0;
-		private static Vector2[] mushroomBiomesPosition = new Vector2[maxMushroomBiomes];
+		public static Vector2[] mushroomBiomesPosition = new Vector2[maxMushroomBiomes];
-		private static int maxLakes = 50;
+		public static int maxLakes = 50;
-		private static int numLakes = 0;
+		public static int numLakes = 0;
-		private static int[] LakeX = new int[maxLakes];
+		public static int[] LakeX = new int[maxLakes];
-		private static int maxOceanCaveTreasure = 2;
+		public static int maxOceanCaveTreasure = 2;
-		private static int numOceanCaveTreasure = 0;
+		public static int numOceanCaveTreasure = 0;
-		private static Point[] oceanCaveTreasure = new Point[maxOceanCaveTreasure];
+		public static Point[] oceanCaveTreasure = new Point[maxOceanCaveTreasure];
-		private static int cactusWaterWidth = 50;
+		public static int cactusWaterWidth = 50;
-		private static int cactusWaterHeight = 25;
+		public static int cactusWaterHeight = 25;
-		private static int cactusWaterLimit = 25;
+		public static int cactusWaterLimit = 25;
-		private static int JungleX;
+		public static int JungleX;
-		private static int hellChest;
+		public static int hellChest;
-		private static int[] hellChestItem = new int[7];
+		public static int[] hellChestItem = new int[7];
-		private static bool roomTorch;
+		public static bool roomTorch;
-		private static bool roomDoor;
+		public static bool roomDoor;
-		private static bool roomChair;
+		public static bool roomChair;
-		private static bool roomTable;
+		public static bool roomTable;
-		private static bool roomOccupied;
+		public static bool roomOccupied;
-		private static bool roomEvil;
+		public static bool roomEvil;
 		public static Point16[] statueList;
 		public static List<int> StatuesWithTraps = new List<int>(new int[4] {
 			4,
@@ -870,16 +_,16 @@
 		public static Rectangle UndergroundDesertLocation = Rectangle.Empty;
 		public static Rectangle UndergroundDesertHiveLocation = Rectangle.Empty;
 		public static MysticLogFairiesEvent mysticLogsEvent = new MysticLogFairiesEvent();
-		private static bool currentlyTryingToUseAlternateHousingSpot;
+		public static bool currentlyTryingToUseAlternateHousingSpot;
-		private static int sharedRoomX;
+		public static int sharedRoomX;
 		public static TownNPCRoomCheckFailureReason roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;
 		public static bool generatingWorld = false;
-		private static int[,] trapDiag = new int[4, 2];
+		public static int[,] trapDiag = new int[4, 2];
-		private static int tileCounterNum;
+		public static int tileCounterNum;
-		private static int tileCounterMax = 20;
+		public static int tileCounterMax = 20;
-		private static int[] tileCounterX = new int[tileCounterMax];
+		public static int[] tileCounterX = new int[tileCounterMax];
-		private static int[] tileCounterY = new int[tileCounterMax];
+		public static int[] tileCounterY = new int[tileCounterMax];
-		private static WorldGenerator _generator;
+		public static WorldGenerator _generator;
 		public static int SmallConsecutivesFound = 0;
 		public static int SmallConsecutivesEliminated = 0;
 		public static bool drunkWorldGen = false;
@@ -888,12 +_,58 @@
 		public static bool placingTraps = false;
 		public const bool USE_FRAMING_SKIP_FOR_UNIMPORTANT_TILES_IN_WORLDGEN = false;
 		public static bool notTheBees = false;
-		private static int catTailDistance = 8;
+		public static int catTailDistance = 8;
 		public static TreeTopsInfo TreeTops = new TreeTopsInfo();
 		public static BackgroundChangeFlashInfo BackgroundsCache = new BackgroundChangeFlashInfo();
-		private static bool fossilBreak = false;
+		public static bool fossilBreak = false;
-		private const bool BUBBLES_SOLID_STATE_FOR_HOUSING = true;
+		public const bool BUBBLES_SOLID_STATE_FOR_HOUSING = true;
-		private static bool skipFramingDuringGen = false;
+		public static bool skipFramingDuringGen = false;
+
+		//local vars turned to public below
+		public static int copper = 7;
+		public static int iron = 6;
+		public static int silver = 9;
+		public static int gold = 8;
+		public static int dungeonSide = 0;
+		public static ushort jungleHut = 0;
+		public static int shellStartXLeft = 0;
+		public static int shellStartYLeft = 0;
+		public static int shellStartXRight = 0;
+		public static int shellStartYRight = 0;
+		public static int howFar = 0;
+		public static int[] PyrX = null;
+		public static int[] PyrY = null;
+		public static int numPyr = 0;
+		public static int jungleMinX = -1;
+		public static int jungleMaxX = -1;
+		public static int[] snowMinX = new int[Main.maxTilesY];
+		public static int[] snowMaxX = new int[Main.maxTilesY];
+		public static int snowTop = 0;
+		public static int snowBottom = 0;
+		public static float dub2 = 0f;
+		public static int skyLakes = 1;
+		public static int beachSandRandomCenter = 275 + 5 + 40;
+		public static int beachSandRandomWidthRange = 20;
+		public static int beachSandDungeonExtraWidth = 40;
+		public static int beachSandJungleExtraWidth = 20;
+		public static int oceanWaterStartRandomMin = 220;
+		public static int oceanWaterStartRandomMax = oceanWaterStartRandomMin + 40;
+		public static int oceanWaterForcedJungleLength = 275;
+		public static int leftBeachEnd = 0;
+		public static int rightBeachStart = 0;
+		public static int minSsandBeforeWater = 50;
+		public static int evilBiomeBeachAvoidance = beachSandRandomCenter + 60;
+		public static int evilBiomeAvoidanceMidFixer = 50;
+		public static int lakesBeachAvoidance = beachSandRandomCenter + 20;
+		public static int smallHolesBeachAvoidance = beachSandRandomCenter + 20;
+		public static int surfaceCavesBeachAvoidance2 = beachSandRandomCenter + 20;
+		public static int jungleOriginX = 0;
+		public static int snowOriginLeft = 0;
+		public static int snowOriginRight = 0;
+		public static int logX = -1;
+		public static int logY = -1;
+		public static int dungeonLocation = 0;
+
 
 		public static UnifiedRandom genRand {
 			get {
@@ -1214,7 +_,7 @@
 			}
 
 			int num2 = -1;
-			for (int j = 0; j < 665; j++) {
+			for (int j = 0; j < Main.townNPCCanSpawn.Length; j++) {
 				if (!Main.townNPCCanSpawn[j] || !CheckSpecialTownNPCSpawningConditions(j))
 					continue;
 
@@ -1240,6 +_,8 @@
 		}
 
 		public static bool CheckSpecialTownNPCSpawningConditions(int type) {
+			if (!NPCLoader.CheckConditions(type))
+				return false;
 			if (type == 160) {
 				if ((double)roomY2 > Main.worldSurface)
 					return false;
@@ -1570,7 +_,7 @@
 			return TownNPCSpawnResult.Successful;
 		}
 
-		private static int FindAHomelessNPC() {
+		public static int FindAHomelessNPC() {
 			int result = -1;
 			for (int i = 0; i < 200; i++) {
 				if (Main.npc[i].active && Main.npc[i].homeless && Main.npc[i].type == prioritizedTownNPCType && CheckSpecialTownNPCSpawningConditions(Main.npc[i].type)) {
@@ -1582,7 +_,7 @@
 			return result;
 		}
 
-		private static bool IsRoomConsideredAlreadyOccupied(int spawnTileX, int spawnTileY, int npcTypeToSpawn) {
+		public static bool IsRoomConsideredAlreadyOccupied(int spawnTileX, int spawnTileY, int npcTypeToSpawn) {
 			bool result = false;
 			for (int i = 0; i < 200; i++) {
 				NPC nPC = Main.npc[i];
@@ -1695,7 +_,7 @@
 			Main.tileSolid[379] = flag;
 		}
 
-		private static bool IsRoomConsideredOccupiedForNPCIndex(int npc) {
+		public static bool IsRoomConsideredOccupiedForNPCIndex(int npc) {
 			bool result = true;
 			for (int i = 0; i < 200; i++) {
 				if (i != npc) {
@@ -1710,7 +_,7 @@
 			return result;
 		}
 
-		private static bool ScoreRoom_IsThisRoomOccupiedBySomeone(int ignoreNPC = -1, int npcTypeAsking = -1) {
+		public static bool ScoreRoom_IsThisRoomOccupiedBySomeone(int ignoreNPC = -1, int npcTypeAsking = -1) {
 			for (int i = 0; i < 200; i++) {
 				if (!Main.npc[i].active || !Main.npc[i].townNPC || ignoreNPC == i || Main.npc[i].homeless)
 					continue;
@@ -1801,7 +_,7 @@
 			if (num7 >= Main.maxTilesY - 5)
 				num7 = Main.maxTilesY - 6;
 
-			int[] tileTypeCounts = new int[624];
+			int[] tileTypeCounts = new int[TileLoader.TileCount];
 			CountTileTypesInArea(tileTypeCounts, num4 + 1, num5 - 1, num6 + 2, num7 + 1);
 			int num8 = -GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.TotalGoodEvil);
 			if (num8 < 50)
@@ -1890,7 +_,7 @@
 			}
 		}
 
-		private static bool ScoreRoom_CanBeHomeSpot(int x, int y) {
+		public static bool ScoreRoom_CanBeHomeSpot(int x, int y) {
 			Tile tile = Main.tile[x, y];
 			if (tile.active()) {
 				ushort type = tile.type;
@@ -1901,7 +_,7 @@
 			return true;
 		}
 
-		private static bool Housing_CheckIfIsCeiling(int i, int j) {
+		public static bool Housing_CheckIfIsCeiling(int i, int j) {
 			bool result = false;
 			for (int k = 0; k < roomCeilingsCount; k++) {
 				if (roomCeilingX[k] == i) {
@@ -1915,7 +_,7 @@
 			return result;
 		}
 
-		private static bool Housing_CheckIfInRoom(int i, int j) {
+		public static bool Housing_CheckIfInRoom(int i, int j) {
 			bool result = false;
 			for (int k = 0; k < numRoomTiles; k++) {
 				if (roomX[k] == i && roomY[k] == j) {
@@ -1934,7 +_,7 @@
 			roomY2 = y;
 			numRoomTiles = 0;
 			roomCeilingsCount = 0;
-			for (int i = 0; i < 624; i++) {
+			for (int i = 0; i < houseTile.Length; i++) {
 				houseTile[i] = false;
 			}
 
@@ -2007,6 +_,8 @@
 				houseTile[Main.tile[x, y].type] = true;
 				if (Main.tileSolid[Main.tile[x, y].type] || (Main.tile[x, y].type == 11 && (Main.tile[x, y].frameX == 0 || Main.tile[x, y].frameX == 54 || Main.tile[x, y].frameX == 72 || Main.tile[x, y].frameX == 126)) || Main.tile[x, y].type == 389 || (Main.tile[x, y].type == 386 && ((Main.tile[x, y].frameX < 36 && Main.tile[x, y].frameY == 18) || (Main.tile[x, y].frameX >= 36 && Main.tile[x, y].frameY == 0))))
 					return;
+				if (TileLoader.CloseDoorID(Main.tile[x, y]) >= 0 && (Main.tile[x, y].frameX == 0 || Main.tile[x, y].frameX == 54 || Main.tile[x, y].frameX == 72 || Main.tile[x, y].frameX == 126))
+					return;
 			}
 
 			if (x < roomX1)
@@ -2121,6 +_,8 @@
 		}
 
 		public static bool meteor(int i, int j, bool ignorePlayers = false) {
+			var meteorTasks = new List<GenPass>();
+
 			if (i < 50 || i > Main.maxTilesX - 50)
 				return false;
 
@@ -2163,101 +_,110 @@
 				}
 			}
 
+			meteorTasks.Add(new PassLegacy("Meteor Spawn", (progress, config) => {
+				num = genRand.Next(17, 23);
+				for (int num2 = i - num; num2 < i + num; num2++) {
+					for (int num3 = j - num; num3 < j + num; num3++) {
+						if (num3 <= j + Main.rand.Next(-2, 3) - 5)
+							continue;
+
+						float num4 = Math.Abs(i - num2);
+						float num5 = Math.Abs(j - num3);
+						if ((double)(float)Math.Sqrt(num4 * num4 + num5 * num5) < (double)num * 0.9 + (double)Main.rand.Next(-4, 5)) {
+							if (!Main.tileSolid[Main.tile[num2, num3].type])
+								Main.tile[num2, num3].active(active: false);
+
+							Main.tile[num2, num3].type = 37;
+						}
+					}
+				}
+
+				num = genRand.Next(8, 14);
+				for (int num6 = i - num; num6 < i + num; num6++) {
+					for (int num7 = j - num; num7 < j + num; num7++) {
+						if (num7 > j + Main.rand.Next(-2, 3) - 4) {
+							float num8 = Math.Abs(i - num6);
+							float num9 = Math.Abs(j - num7);
+							if ((double)(float)Math.Sqrt(num8 * num8 + num9 * num9) < (double)num * 0.8 + (double)Main.rand.Next(-3, 4))
+								Main.tile[num6, num7].active(active: false);
+						}
+					}
+				}
+
+				num = genRand.Next(25, 35);
+				for (int num10 = i - num; num10 < i + num; num10++) {
+					for (int num11 = j - num; num11 < j + num; num11++) {
+						float num12 = Math.Abs(i - num10);
+						float num13 = Math.Abs(j - num11);
+						if ((double)(float)Math.Sqrt(num12 * num12 + num13 * num13) < (double)num * 0.7) {
+							if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num10, num11].type])
+								KillTile(num10, num11);
+
+							Main.tile[num10, num11].liquid = 0;
+						}
+
+						if (Main.tile[num10, num11].type == 37) {
+							if (!SolidTile(num10 - 1, num11) && !SolidTile(num10 + 1, num11) && !SolidTile(num10, num11 - 1) && !SolidTile(num10, num11 + 1))
+								Main.tile[num10, num11].active(active: false);
+							else if ((Main.tile[num10, num11].halfBrick() || Main.tile[num10 - 1, num11].topSlope()) && !SolidTile(num10, num11 + 1))
+								Main.tile[num10, num11].active(active: false);
+						}
+
+						SquareTileFrame(num10, num11);
+						SquareWallFrame(num10, num11);
+					}
+				}
+
+				num = genRand.Next(23, 32);
+				for (int num14 = i - num; num14 < i + num; num14++) {
+					for (int num15 = j - num; num15 < j + num; num15++) {
+						if (num15 <= j + genRand.Next(-3, 4) - 3 || !Main.tile[num14, num15].active() || Main.rand.Next(10) != 0)
+							continue;
+
+						float num16 = Math.Abs(i - num14);
+						float num17 = Math.Abs(j - num15);
+						if ((double)(float)Math.Sqrt(num16 * num16 + num17 * num17) < (double)num * 0.8) {
+							if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num14, num15].type])
+								KillTile(num14, num15);
+
+							Main.tile[num14, num15].type = 37;
+							SquareTileFrame(num14, num15);
+						}
+					}
+				}
+
+				num = genRand.Next(30, 38);
+				for (int num18 = i - num; num18 < i + num; num18++) {
+					for (int num19 = j - num; num19 < j + num; num19++) {
+						if (num19 <= j + genRand.Next(-2, 3) || !Main.tile[num18, num19].active() || Main.rand.Next(20) != 0)
+							continue;
+
+						float num20 = Math.Abs(i - num18);
+						float num21 = Math.Abs(j - num19);
+						if ((double)(float)Math.Sqrt(num20 * num20 + num21 * num21) < (double)num * 0.85) {
+							if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num18, num19].type])
+								KillTile(num18, num19);
+
+							Main.tile[num18, num19].type = 37;
+							SquareTileFrame(num18, num19);
+						}
+					}
+				}
+			}));
+
+			meteorTasks.Add(new PassLegacy("Meteor Announcement", (progress, config) => {
+				if (Main.netMode == 0)
+					Main.NewText(Lang.gen[59].Value, 50, byte.MaxValue, 130);
+				else if (Main.netMode == 2)
+					ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.gen[59].Key), new Color(50, 255, 130));
+			}));
+
 			stopDrops = true;
-			num = genRand.Next(17, 23);
-			for (int num2 = i - num; num2 < i + num; num2++) {
-				for (int num3 = j - num; num3 < j + num; num3++) {
-					if (num3 <= j + Main.rand.Next(-2, 3) - 5)
-						continue;
-
-					float num4 = Math.Abs(i - num2);
-					float num5 = Math.Abs(j - num3);
-					if ((double)(float)Math.Sqrt(num4 * num4 + num5 * num5) < (double)num * 0.9 + (double)Main.rand.Next(-4, 5)) {
-						if (!Main.tileSolid[Main.tile[num2, num3].type])
-							Main.tile[num2, num3].active(active: false);
-
-						Main.tile[num2, num3].type = 37;
-					}
-				}
-			}
-
-			num = genRand.Next(8, 14);
-			for (int num6 = i - num; num6 < i + num; num6++) {
-				for (int num7 = j - num; num7 < j + num; num7++) {
-					if (num7 > j + Main.rand.Next(-2, 3) - 4) {
-						float num8 = Math.Abs(i - num6);
-						float num9 = Math.Abs(j - num7);
-						if ((double)(float)Math.Sqrt(num8 * num8 + num9 * num9) < (double)num * 0.8 + (double)Main.rand.Next(-3, 4))
-							Main.tile[num6, num7].active(active: false);
-					}
-				}
-			}
-
-			num = genRand.Next(25, 35);
-			for (int num10 = i - num; num10 < i + num; num10++) {
-				for (int num11 = j - num; num11 < j + num; num11++) {
-					float num12 = Math.Abs(i - num10);
-					float num13 = Math.Abs(j - num11);
-					if ((double)(float)Math.Sqrt(num12 * num12 + num13 * num13) < (double)num * 0.7) {
-						if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num10, num11].type])
-							KillTile(num10, num11);
-
-						Main.tile[num10, num11].liquid = 0;
-					}
-
-					if (Main.tile[num10, num11].type == 37) {
-						if (!SolidTile(num10 - 1, num11) && !SolidTile(num10 + 1, num11) && !SolidTile(num10, num11 - 1) && !SolidTile(num10, num11 + 1))
-							Main.tile[num10, num11].active(active: false);
-						else if ((Main.tile[num10, num11].halfBrick() || Main.tile[num10 - 1, num11].topSlope()) && !SolidTile(num10, num11 + 1))
-							Main.tile[num10, num11].active(active: false);
-					}
-
-					SquareTileFrame(num10, num11);
-					SquareWallFrame(num10, num11);
-				}
-			}
-
-			num = genRand.Next(23, 32);
-			for (int num14 = i - num; num14 < i + num; num14++) {
-				for (int num15 = j - num; num15 < j + num; num15++) {
-					if (num15 <= j + genRand.Next(-3, 4) - 3 || !Main.tile[num14, num15].active() || Main.rand.Next(10) != 0)
-						continue;
-
-					float num16 = Math.Abs(i - num14);
-					float num17 = Math.Abs(j - num15);
-					if ((double)(float)Math.Sqrt(num16 * num16 + num17 * num17) < (double)num * 0.8) {
-						if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num14, num15].type])
-							KillTile(num14, num15);
-
-						Main.tile[num14, num15].type = 37;
-						SquareTileFrame(num14, num15);
-					}
-				}
-			}
-
-			num = genRand.Next(30, 38);
-			for (int num18 = i - num; num18 < i + num; num18++) {
-				for (int num19 = j - num; num19 < j + num; num19++) {
-					if (num19 <= j + genRand.Next(-2, 3) || !Main.tile[num18, num19].active() || Main.rand.Next(20) != 0)
-						continue;
-
-					float num20 = Math.Abs(i - num18);
-					float num21 = Math.Abs(j - num19);
-					if ((double)(float)Math.Sqrt(num20 * num20 + num21 * num21) < (double)num * 0.85) {
-						if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num18, num19].type])
-							KillTile(num18, num19);
-
-						Main.tile[num18, num19].type = 37;
-						SquareTileFrame(num18, num19);
-					}
-				}
-			}
-
+			WorldHooks.ModifyMeteorTasks(meteorTasks);
+			foreach (GenPass task in meteorTasks) {
+				task.Apply(null, null);
+			}
 			stopDrops = false;
-			if (Main.netMode == 0)
-				Main.NewText(Lang.gen[59].Value, 50, byte.MaxValue, 130);
-			else if (Main.netMode == 2)
-				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.gen[59].Key), new Color(50, 255, 130));
 
 			if (Main.netMode != 1)
 				NetMessage.SendTileSquare(-1, i, j, 40);
@@ -2273,10 +_,20 @@
 		}
 
 		public static void worldGenCallback(object threadContext) {
+			try {
+				do_worldGenCallBack(threadContext);
+			}
+			catch (Exception e) {
+				Logging.Terraria.Error(Language.GetTextValue("tModLoader.WorldGenError"), e);
+			}
+		}
+
+		public static void do_worldGenCallBack(object threadContext) {
 			SoundEngine.PlaySound(10);
 			clearWorld();
 			GenerateWorld(Main.ActiveWorldFileData.Seed, threadContext as GenerationProgress);
 			WorldFile.SaveWorld(Main.ActiveWorldFileData.IsCloudSave, resetTime: true);
+			BackupIO.archiveLock = false;
 			if (Main.menuMode == 10 || Main.menuMode == 888)
 				Main.menuMode = 6;
 
@@ -2370,10 +_,21 @@
 
 		public static void SaveAndQuit(Action callback = null) {
 			SoundEngine.PlaySound(11);
+			ModHooks.PreSaveAndQuit();
 			ThreadPool.QueueUserWorkItem(SaveAndQuitCallBack, callback);
 		}
 
 		public static void playWorldCallBack(object threadContext) {
+			try {
+				Logging.Terraria.InfoFormat("Loading World: {0}, IsCloud={1}", Main.ActiveWorldFileData.Name, Main.ActiveWorldFileData.IsCloudSave);
+				do_playWorldCallBack(threadContext);
+			}
+			catch (Exception e) {
+				Logging.Terraria.Error(Language.GetTextValue("tModLoader.PlayerLoadWorldFail"), e);
+			}
+		}
+
+		public static void do_playWorldCallBack(object threadContext) {
 			if (Main.rand == null)
 				Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
 
@@ -2403,13 +_,20 @@
 					}
 
 					if (!worldBackup) {
-						Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
+						string message = Language.GetTextValue("Error.LoadFailedNoBackup");
+						if (WorldIO.customDataFail != null) {
+							message = WorldIO.customDataFail.modName + " " + message;
+							message += "\n" + WorldIO.customDataFail.InnerException;
+						}
+
+						Console.WriteLine(message);
 						return;
 					}
 
 					FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bad", isCloudSave);
 					FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
 					FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
+					WorldIO.LoadDedServBackup(Main.worldPathName, isCloudSave);
 					WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
 					if (loadFailed || !loadSuccess) {
 						WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
@@ -2417,7 +_,14 @@
 							FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bak", isCloudSave);
 							FileUtilities.Copy(Main.worldPathName + ".bad", Main.worldPathName, isCloudSave);
 							FileUtilities.Delete(Main.worldPathName + ".bad", isCloudSave);
-							Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
+							WorldIO.RevertDedServBackup(Main.worldPathName, isCloudSave);
+							string message = Language.GetTextValue("Error.LoadFailed");
+							if (WorldIO.customDataFail != null) {
+								message = WorldIO.customDataFail.modName + " " + message;
+								message += "\n" + WorldIO.customDataFail.InnerException;
+							}
+
+							Console.WriteLine(message);
 							return;
 						}
 					}
@@ -2444,6 +_,12 @@
 			if (Main.netMode == 0 && Main.anglerWhoFinishedToday.Contains(Main.player[Main.myPlayer].name))
 				Main.anglerQuestFinished = true;
 
+			// Move rest of method to main thread to fix concurrent modification exceptions
+			Main.OnTickForInternalCodeOnly += FinishPlayWorld;
+		}
+
+		internal static void FinishPlayWorld() {
+			Main.OnTickForInternalCodeOnly -= FinishPlayWorld;
 			Main.player[Main.myPlayer].Spawn(PlayerSpawnContext.SpawningIntoWorld);
 			Main.ActivePlayerFileData.StartPlayTimer();
 			_lastSeed = Main.ActiveWorldFileData.Seed;
@@ -2475,6 +_,7 @@
 		}
 
 		public static void serverLoadWorldCallBack() {
+			Logging.Terraria.InfoFormat("Loading World: {0}, IsCloud={1}", Main.ActiveWorldFileData.Name, Main.ActiveWorldFileData.IsCloudSave);
 			Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
 			WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
 			if (loadFailed || !loadSuccess) {
@@ -2522,6 +_,15 @@
 		public static Task serverLoadWorld() => Task.Factory.StartNew(serverLoadWorldCallBack);
 
 		public static void clearWorld() {
+			Main.mapTargetX = Math.Max(Main.maxTilesX / 1680, 5);
+			Main.mapTargetY = Math.Max(Main.maxTilesY / 1200, 2);
+			Main.instance.mapTarget = new RenderTarget2D[Main.mapTargetX, Main.mapTargetY];
+			Main.initMap = new bool[Main.mapTargetX, Main.mapTargetY];
+			Main.mapWasContentLost = new bool[Main.mapTargetX, Main.mapTargetY];
+
+			Main.Map = new WorldMap(Main.maxTilesX, Main.maxTilesY);
+			Main.tile = new Tile[Main.maxTilesX, Main.maxTilesY];
+
 			Main.ladyBugRainBoost = 0;
 			Main.getGoodWorld = false;
 			Main.drunkWorld = false;
@@ -2739,6 +_,7 @@
 
 			setWorldSize();
 			Star.SpawnStars();
+			WorldHooks.SetupWorld();
 			worldCleared = true;
 		}
 
@@ -3098,7 +_,7 @@
 			}
 		}
 
-		private static void SetForestBGSet(int style, int[] mountainSet, int[] treeSet) {
+		public static void SetForestBGSet(int style, int[] mountainSet, int[] treeSet) {
 			mountainSet[0] = 7;
 			mountainSet[1] = 8;
 			switch (style) {
@@ -3392,7 +_,7 @@
 			setBG(9, random.Next(3));
 		}
 
-		private static int RollRandomForestBGStyle(UnifiedRandom random) {
+		public static int RollRandomForestBGStyle(UnifiedRandom random) {
 			int num = random.Next(11);
 			if ((num == 1 || num == 2) && random.Next(2) == 0)
 				num = random.Next(11);
@@ -3532,7 +_,7 @@
 			Main.jungleBackStyle = genRand.Next(2);
 		}
 
-		private static void ResetGenerator() {
+		public static void ResetGenerator() {
 			numOrePatch = 0;
 			numTunnels = 0;
 			numLakes = 0;
@@ -4607,7 +_,7 @@
 			}
 		}
 
-		private static int FillWallHolesInColumn(int x, int startY, int endY) {
+		public static int FillWallHolesInColumn(int x, int startY, int endY) {
 			int num = 0;
 			x = Utils.Clamp(x, 2, Main.maxTilesX - 1 - 2);
 			startY = Math.Max(startY, 2);
@@ -4629,7 +_,7 @@
 			return num;
 		}
 
-		private static bool FillWallHolesInSpot(int originX, int originY, int maxWallsThreshold) {
+		public static bool FillWallHolesInSpot(int originX, int originY, int maxWallsThreshold) {
 			if (!InWorld(originX, originY, 2))
 				return false;
 
@@ -4775,15 +_,15 @@
 			}
 		}
 
-		private static void AddGenerationPass(string name, WorldGenLegacyMethod method) {
+		public static void AddGenerationPass(string name, WorldGenLegacyMethod method) {
 			_generator.Append(new PassLegacy(name, method));
 		}
 
-		private static void AddGenerationPass(GenPass pass) {
+		public static void AddGenerationPass(GenPass pass) {
 			_generator.Append(pass);
 		}
 
-		private static void AddGenerationPass(string name, float weight, WorldGenLegacyMethod method) {
+		public static void AddGenerationPass(string name, float weight, WorldGenLegacyMethod method) {
 			_generator.Append(new PassLegacy(name, method, weight));
 		}
 
@@ -4851,7 +_,7 @@
 			return result;
 		}
 
-		private static void ScanTileColumnAndRemoveClumps(int x) {
+		public static void ScanTileColumnAndRemoveClumps(int x) {
 			int num = 0;
 			int y = 0;
 			for (int i = 10; i < Main.maxTilesY - 10; i++) {
@@ -5396,39 +_,40 @@
 			Main.lockMenuBGChange = true;
 			WorldGenConfiguration configuration = WorldGenConfiguration.FromEmbeddedPath("Terraria.GameContent.WorldBuilding.Configuration.json");
 			Hooks.ProcessWorldGenConfig(ref configuration);
+			Logging.Terraria.InfoFormat("Generating World: {0}", Main.ActiveWorldFileData.Name);
 			_lastSeed = seed;
 			_generator = new WorldGenerator(seed, configuration);
 			_genRand = new UnifiedRandom(seed);
 			Main.rand = new UnifiedRandom(seed);
-			StructureMap structures = new StructureMap();
+			structures = new StructureMap();
 			worldSurfaceLow = 0.0;
-			double worldSurface = 0.0;
+			worldSurface = 0.0;
-			double worldSurfaceHigh = 0.0;
+			worldSurfaceHigh = 0.0;
-			double rockLayerLow = 0.0;
+			rockLayerLow = 0.0;
-			double rockLayer = 0.0;
+			rockLayer = 0.0;
-			double rockLayerHigh = 0.0;
+			rockLayerHigh = 0.0;
-			int copper = 7;
+			copper = 7;
-			int iron = 6;
+			iron = 6;
-			int silver = 9;
+			silver = 9;
-			int gold = 8;
+			gold = 8;
-			int dungeonSide = 0;
+			dungeonSide = 0;
-			ushort jungleHut = (ushort)genRand.Next(5);
+			jungleHut = (ushort)genRand.Next(5);
-			int shellStartXLeft = 0;
+			shellStartXLeft = 0;
-			int shellStartYLeft = 0;
+			shellStartYLeft = 0;
-			int shellStartXRight = 0;
+			shellStartXRight = 0;
-			int shellStartYRight = 0;
+			shellStartYRight = 0;
-			int howFar = 0;
+			howFar = 0;
-			int[] PyrX = null;
+			PyrX = null;
-			int[] PyrY = null;
+			PyrY = null;
-			int numPyr = 0;
+			numPyr = 0;
-			int jungleMinX = -1;
+			jungleMinX = -1;
-			int jungleMaxX = -1;
+			jungleMaxX = -1;
-			int[] snowMinX = new int[Main.maxTilesY];
+			snowMinX = new int[Main.maxTilesY];
-			int[] snowMaxX = new int[Main.maxTilesY];
+			snowMaxX = new int[Main.maxTilesY];
-			int snowTop = 0;
+			snowTop = 0;
-			int snowBottom = 0;
+			snowBottom = 0;
-			float dub2 = 0f;
+			dub2 = 0f;
-			int skyLakes = 1;
+			skyLakes = 1;
 			if (Main.maxTilesX > 8000)
 				skyLakes++;
 
@@ -5436,28 +_,29 @@
 				skyLakes++;
 
 			int num = 275;
-			int beachSandRandomCenter = num + 5 + 40;
+			beachSandRandomCenter = num + 5 + 40;
-			int beachSandRandomWidthRange = 20;
+			beachSandRandomWidthRange = 20;
-			int beachSandDungeonExtraWidth = 40;
+			beachSandDungeonExtraWidth = 40;
-			int beachSandJungleExtraWidth = 20;
+			beachSandJungleExtraWidth = 20;
-			int oceanWaterStartRandomMin = 220;
+			oceanWaterStartRandomMin = 220;
-			int oceanWaterStartRandomMax = oceanWaterStartRandomMin + 40;
+			oceanWaterStartRandomMax = oceanWaterStartRandomMin + 40;
-			int oceanWaterForcedJungleLength = 275;
+			oceanWaterForcedJungleLength = 275;
-			int leftBeachEnd = 0;
+			leftBeachEnd = 0;
-			int rightBeachStart = 0;
+			rightBeachStart = 0;
-			int minSsandBeforeWater = 50;
+			minSsandBeforeWater = 50;
-			int evilBiomeBeachAvoidance = beachSandRandomCenter + 60;
+			evilBiomeBeachAvoidance = beachSandRandomCenter + 60;
-			int evilBiomeAvoidanceMidFixer = 50;
+			evilBiomeAvoidanceMidFixer = 50;
-			int lakesBeachAvoidance = beachSandRandomCenter + 20;
+			lakesBeachAvoidance = beachSandRandomCenter + 20;
-			int smallHolesBeachAvoidance = beachSandRandomCenter + 20;
+			smallHolesBeachAvoidance = beachSandRandomCenter + 20;
 			_ = beachSandRandomCenter;
-			int surfaceCavesBeachAvoidance2 = beachSandRandomCenter + 20;
+			surfaceCavesBeachAvoidance2 = beachSandRandomCenter + 20;
-			int jungleOriginX = 0;
+			jungleOriginX = 0;
-			int snowOriginLeft = 0;
+			snowOriginLeft = 0;
-			int snowOriginRight = 0;
+			snowOriginRight = 0;
-			int logX = -1;
+			logX = -1;
-			int logY = -1;
+			logY = -1;
-			int dungeonLocation = 0;
+			dungeonLocation = 0;
+			WorldHooks.PreWorldGen();
 			AddGenerationPass("Reset", delegate (GenerationProgress progress, GameConfiguration passConfig) {
 				numOceanCaveTreasure = 0;
 				skipDesertTileCheck = false;
@@ -8082,7 +_,7 @@
 								int num543 = genRand.Next(num528 - num536, num528 + num536 + 1);
 								int num544 = genRand.Next(num529 - num537, num529 + num537 - 2);
 								PlaceTile(num543, num544, 4, mute: true, forced: false, -1, 3);
-								if (Main.tile[num543, num544].type == 4)
+								if (TileID.Sets.Torch[Main.tile[num543, num544].type])
 									flag35 = true;
 							}
 
@@ -11145,7 +_,7 @@
 							}
 						}
 
-						if (TileID.Sets.BasicChest[Main.tile[num54, num55].type]) {
+						if (TileID.Sets.BasicChest[Main.tile[num54, num55].type] && Main.tile[num54, num55].type < TileID.Count) {
 							int num83 = Main.tile[num54, num55].frameX / 18;
 							int num84 = 0;
 							ushort type = 21;
@@ -11334,7 +_,7 @@
 			});
 
 			AddGenerationPass("Micro Biomes", delegate (GenerationProgress progress, GameConfiguration passConfig) {
-				progress.Message = Lang.gen[76].Value;
+				progress.Message = Lang.gen[76].Value+"..Dead Man's Chests";
 				_ = (float)(Main.maxTilesX * Main.maxTilesY) / 5040000f;
 				float num27 = 10f;
 				if (getGoodWorldGen)
@@ -11352,6 +_,7 @@
 					possibleChestsToTrapify.Remove(num29);
 				}
 
+				progress.Message = Lang.gen[76].Value+"..Thin Ice";
 				progress.Set(1f / num27);
 				if (!notTheBees) {
 					ThinIceBiome thinIceBiome = configuration.CreateBiome<ThinIceBiome>();
@@ -11374,6 +_,7 @@
 					}
 				}
 
+				progress.Message = Lang.gen[76].Value+"..Sword Shrines";
 				progress.Set(0.1f);
 				progress.Set(2f / num27);
 				EnchantedSwordBiome enchantedSwordBiome = configuration.CreateBiome<EnchantedSwordBiome>();
@@ -11396,6 +_,7 @@
 					}
 				}
 
+				progress.Message = Lang.gen[76].Value+"..Campsites";
 				progress.Set(0.2f);
 				progress.Set(3f / num27);
 				if (!notTheBees) {
@@ -11408,6 +_,7 @@
 					}
 				}
 
+				progress.Message = Lang.gen[76].Value+"..Explosive Traps";
 				progress.Set(4f / num27);
 				if (!notTheBees) {
 					MiningExplosivesBiome miningExplosivesBiome = configuration.CreateBiome<MiningExplosivesBiome>();
@@ -11422,6 +_,7 @@
 					}
 				}
 
+				progress.Message = Lang.gen[76].Value+"..Living Trees";
 				progress.Set(0.3f);
 				progress.Set(5f / num27);
 				MahoganyTreeBiome mahoganyTreeBiome = configuration.CreateBiome<MahoganyTreeBiome>();
@@ -11435,9 +_,11 @@
 					num40++;
 				}
 
+				progress.Message = Lang.gen[76].Value+"..Long Minecart Tracks";
 				progress.Set(0.4f);
 				progress.Set(6f / num27);
 				progress.Set(7f / num27);
+				// Extra patch context.
 				TrackGenerator trackGenerator = new TrackGenerator();
 				int random6 = passConfig.Get<WorldGenRange>("LongTrackCount").GetRandom(genRand);
 				WorldGenRange worldGenRange = passConfig.Get<WorldGenRange>("LongTrackLength");
@@ -11458,6 +_,7 @@
 					}
 				}
 
+				progress.Message = Lang.gen[76].Value+"..Standard Minecart Tracks";
 				progress.Set(8f / num27);
 				random6 = passConfig.Get<WorldGenRange>("StandardTrackCount").GetRandom(genRand);
 				worldGenRange = passConfig.Get<WorldGenRange>("StandardTrackLength");
@@ -11477,6 +_,7 @@
 					}
 				}
 
+				progress.Message = Lang.gen[76].Value+"..Lava Traps";
 				progress.Set(9f / num27);
 				if (!notTheBees) {
 					double num45 = (double)Main.maxTilesX * 0.02;
@@ -11808,14 +_,17 @@
 				progress.Message = Lang.gen[87].Value;
 			});
 
+			WorldHooks.ModifyWorldGenTasks(_generator._passes, ref _generator._totalLoadWeight);
 			_generator.GenerateWorld(customProgressObject);
 			ConsumePostGenActions(structures);
+			WorldHooks.PostWorldGen();
 			Main.WorldFileMetadata = FileMetadata.FromCurrentSettings(FileType.World);
 			Main.NotifyOfEvent(GameNotificationType.WorldGen);
 			drunkWorldGenText = false;
+			BackupIO.archiveLock = true;
 		}
 
-		private static void NotTheBees() {
+		public static void NotTheBees() {
 			if (!notTheBees)
 				return;
 
@@ -11905,7 +_,7 @@
 			}
 		}
 
-		private static void FinishNotTheBees() {
+		public static void FinishNotTheBees() {
 			if (!notTheBees)
 				return;
 
@@ -12035,7 +_,7 @@
 			}
 		}
 
-		private static void FinishGetGoodWorld() {
+		public static void FinishGetGoodWorld() {
 			int num = 0;
 			for (int i = 20; (double)i < Main.worldSurface; i++) {
 				for (int j = 20; j < Main.maxTilesX - 20; j++) {
@@ -12150,7 +_,7 @@
 			}
 		}
 
-		private static void FinishDrunkGen() {
+		public static void FinishDrunkGen() {
 			byte color = (byte)genRand.Next(13, 25);
 			byte b = 16;
 			for (int i = 0; i < Main.maxTilesX; i++) {
@@ -12320,7 +_,7 @@
 			}
 		}
 
-		private static float TuneOceanDepth(int count, float depth, bool floridaStyle = false) {
+		public static float TuneOceanDepth(int count, float depth, bool floridaStyle = false) {
 			if (!floridaStyle) {
 				if (count < 3)
 					depth += (float)genRand.Next(10, 20) * 0.2f;
@@ -12443,7 +_,7 @@
 			if (tile2.wall != 0 || tile2.liquid != 0)
 				return false;
 
-			if (tile.type != 53 && tile.type != 234 && tile.type != 116 && tile.type != 112)
+			if (tile.type != 53 && tile.type != 234 && tile.type != 116 && tile.type != 112 && !TileLoader.CanGrowModPalmTree(tile.type))
 				return false;
 
 			if (!EmptyTileCheck(i, i, num - 2, num - 1, 20))
@@ -12505,10 +_,10 @@
 
 		public static bool GrowEpicTree(int i, int y) {
 			int j;
-			for (j = y; Main.tile[i, j].type == 20; j++) {
+			for (j = y; TileID.Sets.TreeSapling[Main.tile[i, j].type]; j++) {
 			}
 
-			if (Main.tile[i, j].active() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && Main.tile[i, j].type == 2 && Main.tile[i, j - 1].wall == 0 && Main.tile[i, j - 1].liquid == 0 && ((Main.tile[i - 1, j].active() && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109)) || (Main.tile[i + 1, j].active() && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109)))) {
+			if (Main.tile[i, j].active() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && Main.tile[i, j].type == 2 && Main.tile[i, j - 1].wall == 0 && Main.tile[i, j - 1].liquid == 0 && ((Main.tile[i - 1, j].active() && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i - 1, j].type))) || (Main.tile[i + 1, j].active() && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i + 1, j].type))))) {
 				int num = 2;
 				if (EmptyTileCheck(i - num, i + num, j - 55, j - 1, 20)) {
 					bool flag = false;
@@ -12735,10 +_,10 @@
 					int num5 = genRand.Next(3);
 					bool flag3 = false;
 					bool flag4 = false;
-					if (Main.tile[i - 1, j].active() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109))
+					if (Main.tile[i - 1, j].active() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i - 1, j].type)))
 						flag3 = true;
 
-					if (Main.tile[i + 1, j].active() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109))
+					if (Main.tile[i + 1, j].active() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i + 1, j].type)))
 						flag4 = true;
 
 					if (!flag3) {
@@ -13834,7 +_,7 @@
 			return true;
 		}
 
-		private static bool GrowLivingTree_HorizontalTunnel(int i, int j) {
+		public static bool GrowLivingTree_HorizontalTunnel(int i, int j) {
 			int num = i;
 			int num2 = i;
 			int num3 = 80;
@@ -14014,7 +_,7 @@
 			return true;
 		}
 
-		private static void GrowDungeonTree_MakePassage(int j, int W, ref int minl, ref int minr, bool noSecretRoom = false) {
+		public static void GrowDungeonTree_MakePassage(int j, int W, ref int minl, ref int minr, bool noSecretRoom = false) {
 			int num = minl;
 			int num2 = minr;
 			_ = (minl + minr) / 2;
@@ -14130,7 +_,7 @@
 			}
 		}
 
-		private static void GrowLivingTree_MakePassage(int j, int W, ref int minl, ref int minr, bool noSecretRoom = false) {
+		public static void GrowLivingTree_MakePassage(int j, int W, ref int minl, ref int minr, bool noSecretRoom = false) {
 			bool flag = noSecretRoom;
 			int num = minl;
 			int num2 = minr;
@@ -14302,7 +_,7 @@
 			}
 		}
 
-		private static void GrowLivingTreePassageRoom(int minl, int minr, int Y) {
+		public static void GrowLivingTreePassageRoom(int minl, int minr, int Y) {
 			int num = genRand.Next(2);
 			if (num == 0)
 				num = -1;
@@ -14473,6 +_,14 @@
 					continue;
 				}
 
+				TileLoader.TreeGrowthFXGore(tile2.type,ref passStyle);
+				if(passStyle > 0)
+					break;
+
+				TileLoader.PalmTreeGrowthFXGore(tile2.type,ref passStyle);
+				if(passStyle > 0)
+					break;
+
 				GetTreeLeaf(x, topTile, tile2, ref treeHeight, out int _, out passStyle);
 				break;
 			}
@@ -14726,13 +_,13 @@
 				case 492:
 					return true;
 				default:
-					return false;
+					return TileLoader.CanGrowModTree(type);
 			}
 		}
 
 		public static bool GrowTree(int i, int y) {
 			int j;
-			for (j = y; Main.tile[i, j].type == 20; j++) {
+			for (j = y; TileID.Sets.TreeSapling[Main.tile[i, j].type]; j++) {
 			}
 
 			if ((Main.tile[i - 1, j - 1].liquid != 0 || Main.tile[i, j - 1].liquid != 0 || Main.tile[i + 1, j - 1].liquid != 0) && !notTheBees)
@@ -15880,10 +_,10 @@
 			int num6 = genRand.Next(3);
 			bool flag3 = false;
 			bool flag4 = false;
-			if (Main.tile[i - 1, y].nactive() && !Main.tile[i - 1, y].halfBrick() && Main.tile[i - 1, y].slope() == 0 && (Main.tile[i - 1, y].type == 2 || Main.tile[i - 1, y].type == 23 || Main.tile[i - 1, y].type == 60 || Main.tile[i - 1, y].type == 109 || Main.tile[i - 1, y].type == 147))
+			if (Main.tile[i - 1, y].nactive() && !Main.tile[i - 1, y].halfBrick() && Main.tile[i - 1, y].slope() == 0 && (Main.tile[i - 1, y].type == 2 || Main.tile[i - 1, y].type == 23 || Main.tile[i - 1, y].type == 60 || Main.tile[i - 1, y].type == 109 || Main.tile[i - 1, y].type == 147 || TileLoader.CanGrowModTree(Main.tile[i - 1, y].type)))
 				flag3 = true;
 
-			if (Main.tile[i + 1, y].nactive() && !Main.tile[i + 1, y].halfBrick() && Main.tile[i + 1, y].slope() == 0 && (Main.tile[i + 1, y].type == 2 || Main.tile[i + 1, y].type == 23 || Main.tile[i + 1, y].type == 60 || Main.tile[i + 1, y].type == 109 || Main.tile[i + 1, y].type == 147))
+			if (Main.tile[i + 1, y].nactive() && !Main.tile[i + 1, y].halfBrick() && Main.tile[i + 1, y].slope() == 0 && (Main.tile[i + 1, y].type == 2 || Main.tile[i + 1, y].type == 23 || Main.tile[i + 1, y].type == 60 || Main.tile[i + 1, y].type == 109 || Main.tile[i + 1, y].type == 147 || TileLoader.CanGrowModTree(Main.tile[i + 1, y].type)))
 				flag4 = true;
 
 			if (!flag3) {
@@ -16222,6 +_,7 @@
 		}
 
 		public static void smCallBack(object threadContext) {
+			var hardmodeTasks = new List<GenPass>();
 			IsGeneratingHardMode = true;
 			if (Main.rand == null)
 				Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
@@ -16254,8 +_,15 @@
 				num3 = (int)((float)Main.maxTilesX * (1f - num2));
 			}
 
-			GERunner(num3, 0, 3 * num5, 5f);
-			GERunner(num4, 0, 3 * -num5, 5f, good: false);
+			hardmodeTasks.Add(new PassLegacy("Hardmode Good", (progress, config) => {
+				GERunner(num3, 0, 3 * num5, 5f, true);
+			}));
+
+			hardmodeTasks.Add(new PassLegacy("Hardmode Evil", (progress, config) => {
+				GERunner(num4, 0, 3 * -(float)num5, 5f, false);
+			}));
+
+			hardmodeTasks.Add(new PassLegacy("Hardmode Walls", (progress, config) => {
 			float num7 = (float)Main.maxTilesX / 4200f;
 			int num8 = (int)(25f * num7);
 			ShapeData shapeData = new ShapeData();
@@ -16285,13 +_,22 @@
 					shapeData.Clear();
 				}
 			}
+			}));
 
+			hardmodeTasks.Add(new PassLegacy("Hardmode Announcment", (progress, config) => {
 			if (Main.netMode == 0)
 				Main.NewText(Lang.misc[15].Value, 50, byte.MaxValue, 130);
 			else if (Main.netMode == 2)
 				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[15].Key), new Color(50, 255, 130));
 
 			AchievementsHelper.NotifyProgressionEvent(9);
+			}));
+
+			WorldHooks.ModifyHardmodeTasks(hardmodeTasks);
+			foreach (GenPass task in hardmodeTasks) {
+				task.Apply(null, null);
+			}
+
 			if (Main.netMode == 2)
 				Netplay.ResetSections();
 
@@ -16336,7 +_,7 @@
 
 			int frameX = Main.tile[i, j].frameX;
 			Tile tile = Main.tile[i, j];
-			if (tile.type != 11)
+			if (TileLoader.CloseDoorID(Main.tile[i, j]) < 0)
 				return false;
 
 			int num4 = tile.frameY;
@@ -16383,13 +_,14 @@
 				}
 			}
 
+			ushort closeDoorID = (ushort)TileLoader.CloseDoorID(tile);
 			for (int l = num7; l < num7 + 2; l++) {
 				for (int m = num3; m < num3 + 3; m++) {
 					if (l == num2) {
 						if (Main.tile[l, m] == null)
 							Main.tile[l, m] = new Tile();
 
-						Main.tile[l, m].type = 10;
+						Main.tile[l, m].type = closeDoorID;
 						Main.tile[l, m].frameX = (short)(genRand.Next(3) * 18 + num6);
 					}
 					else {
@@ -16553,7 +_,7 @@
 							bool flag2 = false;
 							for (int k = num6 - 8; k < num6 + 8; k++) {
 								for (int l = num7 - 8; l < num7 + 8; l++) {
-									if (Main.tile[k, l].active() && Main.tile[k, l].type == 4) {
+									if (Main.tile[k, l].active() && TileID.Sets.Torch[Main.tile[k, l].type]) {
 										flag2 = true;
 										break;
 									}
@@ -19285,7 +_,7 @@
 			count = MakeDungeon_Banners(array, count);
 		}
 
-		private static void MakeDungeon_Traps(ref int failCount, int failMax, ref int numAdd) {
+		public static void MakeDungeon_Traps(ref int failCount, int failMax, ref int numAdd) {
 			while (numAdd < Main.maxTilesX / 500) {
 				failCount++;
 				int num = genRand.Next(dMinX, dMaxX);
@@ -19304,7 +_,7 @@
 			}
 		}
 
-		private static void MakeDungeon_Lights(ushort tileType, ref int failCount, int failMax, ref int numAdd, int[] roomWall) {
+		public static void MakeDungeon_Lights(ushort tileType, ref int failCount, int failMax, ref int numAdd, int[] roomWall) {
 			int[] array = new int[3] {
 				genRand.Next(7),
 				genRand.Next(7),
@@ -19480,7 +_,7 @@
 			}
 		}
 
-		private static float MakeDungeon_Banners(int[] roomWall, float count) {
+		public static float MakeDungeon_Banners(int[] roomWall, float count) {
 			count = 840000f / (float)Main.maxTilesX;
 			for (int i = 0; (float)i < count; i++) {
 				int num = genRand.Next(dMinX, dMaxX);
@@ -19522,7 +_,7 @@
 			return count;
 		}
 
-		private static float MakeDungeon_Pictures(int[] roomWall, float count) {
+		public static float MakeDungeon_Pictures(int[] roomWall, float count) {
 			count = 420000f / (float)Main.maxTilesX;
 			for (int i = 0; (float)i < count; i++) {
 				int num = genRand.Next(dMinX, dMaxX);
@@ -19774,7 +_,7 @@
 			return count;
 		}
 
-		private static float MakeDungeon_GroundFurniture(int wallType) {
+		public static float MakeDungeon_GroundFurniture(int wallType) {
 			float num = 2000f * (float)Main.maxTilesX / 4200f;
 			int num2 = 1 + Main.maxTilesX / 4200;
 			int num3 = 1 + Main.maxTilesX / 4200;
@@ -21837,7 +_,7 @@
 			return false;
 		}
 
-		private static bool IsUndergroundDesert(int x, int y) {
+		public static bool IsUndergroundDesert(int x, int y) {
 			if ((double)y < Main.worldSurface)
 				return false;
 
@@ -21855,7 +_,7 @@
 			return false;
 		}
 
-		private static bool IsDungeon(int x, int y) {
+		public static bool IsDungeon(int x, int y) {
 			if ((double)y < Main.worldSurface)
 				return false;
 
@@ -23025,7 +_,7 @@
 				Main.tile[i, j] = new Tile();
 
 			Tile tile = Main.tile[i, j];
-			if (tile.type != 10)
+			if (TileLoader.OpenDoorID(Main.tile[i, j]) < 0)
 				return false;
 
 			if (IsLockedDoor(tile))
@@ -23090,8 +_,9 @@
 
 			int num8 = num4 % 36 * 54;
 			SoundEngine.PlaySound(8, i * 16, j * 16);
+			ushort openDoorID = (ushort)TileLoader.OpenDoorID(Main.tile[i, j]);
 			Main.tile[num6, num].active(active: true);
-			Main.tile[num6, num].type = 11;
+			Main.tile[num6, num].type = openDoorID;
 			Main.tile[num6, num].frameY = (short)num8;
 			Main.tile[num6, num].frameX = num2;
 			Main.tile[num6, num].color(color);
@@ -23099,7 +_,7 @@
 				Main.tile[num6 + 1, num] = new Tile();
 
 			Main.tile[num6 + 1, num].active(active: true);
-			Main.tile[num6 + 1, num].type = 11;
+			Main.tile[num6 + 1, num].type = openDoorID;
 			Main.tile[num6 + 1, num].frameY = (short)num8;
 			Main.tile[num6 + 1, num].frameX = (short)(num2 + 18);
 			Main.tile[num6 + 1, num].color(color);
@@ -23107,7 +_,7 @@
 				Main.tile[num6, num + 1] = new Tile();
 
 			Main.tile[num6, num + 1].active(active: true);
-			Main.tile[num6, num + 1].type = 11;
+			Main.tile[num6, num + 1].type = openDoorID;
 			Main.tile[num6, num + 1].frameY = (short)(num8 + 18);
 			Main.tile[num6, num + 1].frameX = num2;
 			Main.tile[num6, num + 1].color(color2);
@@ -23115,7 +_,7 @@
 				Main.tile[num6 + 1, num + 1] = new Tile();
 
 			Main.tile[num6 + 1, num + 1].active(active: true);
-			Main.tile[num6 + 1, num + 1].type = 11;
+			Main.tile[num6 + 1, num + 1].type = openDoorID;
 			Main.tile[num6 + 1, num + 1].frameY = (short)(num8 + 18);
 			Main.tile[num6 + 1, num + 1].frameX = (short)(num2 + 18);
 			Main.tile[num6 + 1, num + 1].color(color2);
@@ -23123,7 +_,7 @@
 				Main.tile[num6, num + 2] = new Tile();
 
 			Main.tile[num6, num + 2].active(active: true);
-			Main.tile[num6, num + 2].type = 11;
+			Main.tile[num6, num + 2].type = openDoorID;
 			Main.tile[num6, num + 2].frameY = (short)(num8 + 36);
 			Main.tile[num6, num + 2].frameX = num2;
 			Main.tile[num6, num + 2].color(color3);
@@ -23131,7 +_,7 @@
 				Main.tile[num6 + 1, num + 2] = new Tile();
 
 			Main.tile[num6 + 1, num + 2].active(active: true);
-			Main.tile[num6 + 1, num + 2].type = 11;
+			Main.tile[num6 + 1, num + 2].type = openDoorID;
 			Main.tile[num6 + 1, num + 2].frameY = (short)(num8 + 36);
 			Main.tile[num6 + 1, num + 2].frameX = (short)(num2 + 18);
 			Main.tile[num6 + 1, num + 2].color(color3);
@@ -23192,6 +_,9 @@
 					KillTile(x, num5 + k);
 			}
 
+			if (!TileLoader.Drop(x, j, type))
+				goto skipDrop;
+
 			if (type == 92)
 				Item.NewItem(x * 16, j * 16, 32, 32, 341);
 
@@ -23301,6 +_,7 @@
 				Item.NewItem(x * 16, j * 16, 32, 32, type2);
 			}
 
+			skipDrop:
 			destroyObject = false;
 		}
 
@@ -23397,6 +_,9 @@
 					KillTile(num + 1, num6 + m);
 			}
 
+			if (!TileLoader.Drop(num, j, type))
+				goto skipDrop;
+
 			if (type == 104) {
 				int num7 = frameX / 36;
 				int num8 = 0;
@@ -23664,6 +_,7 @@
 			if (type == 592)
 				Item.NewItem(num * 16, j * 16, 32, 32, 4867);
 
+			skipDrop:
 			destroyObject = false;
 		}
 
@@ -23974,7 +_,7 @@
 			return true;
 		}
 
-		private static void GetDesiredStalagtiteStyle(int x, int j, out bool fail, out int desiredStyle, out int height, out int y) {
+		public static void GetDesiredStalagtiteStyle(int x, int j, out bool fail, out int desiredStyle, out int height, out int y) {
 			fail = false;
 			desiredStyle = 0;
 			height = 1;
@@ -24026,7 +_,7 @@
 				fail = true;
 		}
 
-		private static void GetStalagtiteStyle(int x, int y, out int style, out bool fail) {
+		public static void GetStalagtiteStyle(int x, int y, out int style, out bool fail) {
 			style = 0;
 			fail = false;
 			switch (Main.tile[x, y].frameX / 54) {
@@ -24570,7 +_,8 @@
 				}
 			}
 
+			if (TileLoader.Drop(x, y, TileID.ChristmasTree))
-			Item.NewItem(x * 16, y * 16, 32, 32, 1873);
+				Item.NewItem(x * 16, y * 16, 32, 32, TileID.ChristmasTree);
 			destroyObject = false;
 		}
 
@@ -24888,7 +_,9 @@
 			if (!SolidTileAllowBottomSlope(x, num + 2) && !TileID.Sets.Platforms[Main.tile[x, num + 2].type])
 				flag = true;
 
-			if (Main.tile[x, num].type == 20) {
+			if (TileID.Sets.TreeSapling[Main.tile[x, num].type]) {
+				int originalType = Main.tile[x, num].type;
+				int newType = TileID.Saplings;
 				int num5 = Main.tile[x, num].frameX / 54;
 				int type2 = Main.tile[x, num + 2].type;
 				int num6 = -1;
@@ -24925,12 +_,16 @@
 					case 112:
 						num6 = 9;
 						break;
+					case int _ when TileLoader.SaplingGrowthType(type2, ref newType, ref num6):
+						break;
 					default:
 						flag = true;
 						break;
 				}
 
-				if (!flag && num5 != num6) {
+				if (!flag && (originalType != newType || num5 != num6)) {
+					Main.tile[x, num].type = (ushort)newType;
+					Main.tile[x, num + 1].type = (ushort)newType;
 					int num7 = 54 * num6;
 					num7 += genRand.Next(3) * 18;
 					Main.tile[x, num].frameX = (short)num7;
@@ -24948,6 +_,9 @@
 			if (Main.tile[x, num + 1].type == type)
 				KillTile(x, num + 1);
 
+			if (!TileLoader.Drop(x, num, type))
+				goto skipDrop;
+
 			if (type == 216)
 				Item.NewItem(x * 16, num * 16, 32, 32, 970 + num3);
 
@@ -25003,6 +_,7 @@
 					break;
 			}
 
+			skipDrop:
 			destroyObject = false;
 		}
 
@@ -25139,6 +_,9 @@
 				if (type != 395)
 					Sign.KillSign(num7, num8);
 
+				if (!TileLoader.Drop(x, y, type))
+					goto skipDrop;
+
 				switch (type) {
 					case 85: {
 							int type2 = 321;
@@ -25177,6 +_,7 @@
 						break;
 				}
 
+				skipDrop:
 				destroyObject = false;
 				return;
 			}
@@ -26075,7 +_,7 @@
 			destroyObject = false;
 		}
 
-		private static int RollRandomSeaShellStyle() {
+		public static int RollRandomSeaShellStyle() {
 			int result = genRand.Next(2);
 			if (genRand.Next(10) == 0)
 				result = 2;
@@ -26370,7 +_,7 @@
 			}
 		}
 
-		private static bool GrowMoreVines(int x, int y) {
+		public static bool GrowMoreVines(int x, int y) {
 			if (!InWorld(x, y, 30))
 				return false;
 
@@ -26398,7 +_,7 @@
 			return true;
 		}
 
-		private static void MatureTheHerbPlants() {
+		public static void MatureTheHerbPlants() {
 			for (int i = 10; i < Main.maxTilesX - 10; i++) {
 				for (int j = 10; j < Main.maxTilesY - 10; j++) {
 					if ((double)j > Main.rockLayer && (Main.tile[i, j + 1].type == 59 || Main.tile[i, j + 1].type == 0) && SolidTile(i, j + 1) && !Main.tile[i, j].active() && Main.tile[i, j].liquid == 0 && genRand.Next(25) == 0) {
@@ -26689,6 +_,9 @@
 					KillTile(x, num + k);
 			}
 
+			if (!TileLoader.Drop(x, num + 1, type))
+				goto skipDrop;
+
 			if (type == 91) {
 				int num3 = frameX / 18;
 				num3 += num2 * 111;
@@ -26726,6 +_,7 @@
 					Item.NewItem(x * 16, (num + 1) * 16, 32, 32, 337 + num3);
 			}
 
+			skipDrop:
 			destroyObject = false;
 		}
 
@@ -26895,7 +_,10 @@
 			}
 
 			destroyObject = true;
+			
+			if (TileLoader.Drop(i, j, TileID.WeaponsRack))
-			Item.NewItem(i * 16, j * 16, 48, 48, 2699);
+				Item.NewItem(i * 16, j * 16, 48, 48, 2699);
+			
 			TEWeaponsRack.Kill(num, num2);
 			for (int m = 0; m < 3; m++) {
 				for (int n = 0; n < 3; n++) {
@@ -27000,7 +_,10 @@
 				return;
 
 			destroyObject = true;
+			
+			if (TileLoader.Drop(i, j, TileID.Mannequin))
-			Item.NewItem(i * 16, j * 16, 32, 32, 498);
+				Item.NewItem(i * 16, j * 16, 32, 32, 498);
+			
 			for (int m = 0; m <= 1; m++) {
 				for (int n = 0; n <= 2; n++) {
 					int num7 = num + m;
@@ -27052,7 +_,10 @@
 				return;
 
 			destroyObject = true;
+			
+			if (TileLoader.Drop(i, j, TileID.Womannequin))
-			Item.NewItem(i * 16, j * 16, 32, 32, 1989);
+				Item.NewItem(i * 16, j * 16, 32, 32, 1989);
+
 			for (int m = 0; m <= 1; m++) {
 				for (int n = 0; n <= 2; n++) {
 					int num7 = num + m;
@@ -27067,7 +_,7 @@
 
 		public static void Place1x2(int x, int y, ushort type, int style) {
 			short frameX = 0;
-			if (type == 20)
+			if (TileID.Sets.TreeSapling[type])
 				frameX = (short)(genRand.Next(3) * 18);
 
 			if (Main.tile[x, y - 1] == null)
@@ -27153,6 +_,9 @@
 			if (Main.tile[x, num + 1].type == type)
 				KillTile(x, num + 1);
 
+			if (!TileLoader.Drop(x, num, type))
+				goto skipDrop;
+
 			switch (type) {
 				case 42: {
 						int type2 = 0;
@@ -27299,6 +_,7 @@
 					break;
 			}
 
+			skipDrop:
 			destroyObject = false;
 		}
 
@@ -27430,6 +_,9 @@
 			if (Main.tile[num + 1, y].type == type)
 				KillTile(num + 1, y);
 
+			if (!TileLoader.Drop(num3, y, type))
+				goto skipDrop;
+
 			if (type == 16) {
 				if (num3 == 1)
 					Item.NewItem(num * 16, y * 16, 32, 32, 716);
@@ -27653,6 +_,7 @@
 					break;
 			}
 
+			skipDrop:
 			destroyObject = false;
 			SquareTileFrame(num, y);
 			SquareTileFrame(num + 1, y);
@@ -27747,6 +_,8 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
 			if (type == 79) {
 				int num6 = 0;
 				switch (num3) {
@@ -27951,6 +_,7 @@
 				Item.NewItem(i * 16, j * 16, 32, 32, type2);
 			}
 
+			skipDrop:
 			destroyObject = false;
 			for (int num7 = num - 1; num7 < num + 4; num7++) {
 				for (int num8 = num2 - 1; num8 < num2 + 4; num8++) {
@@ -27959,7 +_,7 @@
 			}
 		}
 
-		private static bool OasisPlantWaterCheck(int x, int y, bool boost = false) {
+		public static bool OasisPlantWaterCheck(int x, int y, bool boost = false) {
 			int num = 45;
 			int num2 = 20;
 			if (boost) {
@@ -28267,6 +_,8 @@
 				if (!flag)
 					return;
 
+				if (!TileLoader.Drop(i, j, type))
+					goto skipDrop; // do not know the size for this
 				if (type == 238) {
 					float num6 = i * 16;
 					float num7 = j * 16;
@@ -28287,6 +_,7 @@
 				if (type == 236)
 					Item.NewItem(i * 16, j * 16, 32, 32, 1291);
 
+				skipDrop:
 				_ = Main.tile[i, j].frameX;
 				destroyObject = true;
 				for (int n = num; n < num + 2; n++) {
@@ -28580,7 +_,9 @@
 			if (type == 444 && Main.netMode != 1 && !flag6)
 				Projectile.NewProjectile(num2 * 16 + 16, num3 * 16 + 16, 0f, 0f, 655, 0, 0f, Main.myPlayer);
 
-			if (num13 != 0)
+			// FishingCrate, GeyserTrap, and BeeHive
+			// geyser is 2x1
+			if (TileLoader.Drop(num2, num3, type) && num13 != 0)
 				Item.NewItem(num2 * 16, num3 * 16, tileData.CoordinateFullWidth, tileData.CoordinateFullHeight, num13);
 
 			destroyObject = false;
@@ -28646,7 +_,7 @@
 				case 484: {
 						ushort type4 = Main.tile[num2, num6 - 1].type;
 						ushort type5 = Main.tile[num2 + 1, num6 - 1].type;
-						if (!TileID.Sets.BasicChest[type4] && !TileID.Sets.BasicChest[type5] && type4 != 88 && type5 != 88 && !TileID.Sets.BasicChestFake[type4] && !TileID.Sets.BasicChestFake[type5] && type4 != 470 && type5 != 470 && type4 != 475 && type5 != 475 && !SolidTileAllowBottomSlope(num2, num6 + 2) && !SolidTileAllowBottomSlope(num2 + 1, num6 + 2))
+						if (!TileID.Sets.BasicChest[type4] && !TileID.Sets.BasicChest[type5] && !TileID.Sets.BasicDresser[type4] && !TileID.Sets.BasicDresser[type5] && !TileID.Sets.BasicChestFake[type4] && !TileID.Sets.BasicChestFake[type5] && type4 != 470 && type5 != 470 && type4 != 475 && type5 != 475 && !SolidTileAllowBottomSlope(num2, num6 + 2) && !SolidTileAllowBottomSlope(num2 + 1, num6 + 2))
 							flag = true;
 
 						break;
@@ -29000,7 +_,7 @@
 				}
 			}
 
-			if (num13 != 0)
+			if (TileLoader.Drop(i, j, type) && num13 != 0)
 				Item.NewItem(i * 16, j * 16, 32, 32, num13);
 
 			if (type == 138 && !gen && Main.netMode != 1)
@@ -29035,6 +_,9 @@
 		}
 
 		public static bool IsAContainer(Tile t) {
+			if (TileID.Sets.BasicDresser[t.type])
+				return true;
+
 			if (t.type != 88 && t.type != 470 && t.type != 475 && !TileID.Sets.BasicChest[t.type])
 				return TileID.Sets.BasicChestFake[t.type];
 
@@ -29074,7 +_,7 @@
 
 				for (int k = num3; k < num4; k++) {
 					for (int l = num5; l < num6; l++) {
-						if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].active() && (Main.tile[k, l].type == 0 || Main.tile[k, l].type == 1 || Main.tile[k, l].type == 23 || Main.tile[k, l].type == 25 || Main.tile[k, l].type == 40 || Main.tile[k, l].type == 53 || Main.tile[k, l].type == 57 || Main.tile[k, l].type == 59 || Main.tile[k, l].type == 60 || Main.tile[k, l].type == 70 || Main.tile[k, l].type == 109 || Main.tile[k, l].type == 112 || Main.tile[k, l].type == 116 || Main.tile[k, l].type == 117 || Main.tile[k, l].type == 147 || Main.tile[k, l].type == 161 || Main.tile[k, l].type == 163 || Main.tile[k, l].type == 164 || Main.tileMoss[Main.tile[k, l].type] || Main.tile[k, l].type == 199 || Main.tile[k, l].type == 200 || Main.tile[k, l].type == 203 || Main.tile[k, l].type == 234 || (Main.tile[k, l].type == 225 && Main.tile[k, l].wall != 108))) {
+						if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.5 * (1.0 + genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].active() && (TileID.Sets.CanBeClearedDuringOreRunner[Main.tile[k, l].type] || Main.tileMoss[Main.tile[k, l].type] || (Main.tile[k, l].type == 225 && Main.tile[k, l].wall != 108))) {
 							Main.tile[k, l].type = type;
 							SquareTileFrame(k, l);
 							if (Main.netMode == 2)
@@ -29094,6 +_,7 @@
 		}
 
 		public static void SmashAltar(int i, int j) {
+			var altarTasks = new List<GenPass>();
 			if (Main.netMode == 1 || !Main.hardMode || noTileActions || gen)
 				return;
 
@@ -29112,135 +_,148 @@
 					SavedOreTiers.Adamantite = 111;
 			}
 
+			altarTasks.Add(new PassLegacy("Altar Decide Ore", (progress, config) => {
-			switch (num) {
+				switch (num) {
-				case 0: {
+					case 0: {
-						if (SavedOreTiers.Cobalt == -1) {
+							if (SavedOreTiers.Cobalt == -1) {
-							flag = true;
+								flag = true;
-							SavedOreTiers.Cobalt = 107;
-							if (genRand.Next(2) == 0)
-								SavedOreTiers.Cobalt = 221;
-						}
-
-						int num6 = 12;
-						if (SavedOreTiers.Cobalt == 221) {
-							num6 += 9;
-							num3 *= 0.9f;
-						}
-
-						if (Main.netMode == 0)
-							Main.NewText(Lang.misc[num6].Value, 50, byte.MaxValue, 130);
-						else if (Main.netMode == 2)
-							ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num6].Key), new Color(50, 255, 130));
-
-						num = SavedOreTiers.Cobalt;
-						num3 *= 1.05f;
-						break;
-					}
-				case 1: {
-						if (Main.drunkWorld) {
-							if (SavedOreTiers.Mythril == 108)
-								SavedOreTiers.Mythril = 222;
-							else if (SavedOreTiers.Mythril == 222)
-								SavedOreTiers.Mythril = 108;
-						}
-
-						if (SavedOreTiers.Mythril == -1) {
-							flag = true;
-							SavedOreTiers.Mythril = 108;
-							if (genRand.Next(2) == 0)
-								SavedOreTiers.Mythril = 222;
-						}
-
-						int num7 = 13;
-						if (SavedOreTiers.Mythril == 222) {
-							num7 += 9;
-							num3 *= 0.9f;
-						}
-
-						if (Main.netMode == 0)
-							Main.NewText(Lang.misc[num7].Value, 50, byte.MaxValue, 130);
-						else if (Main.netMode == 2)
-							ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num7].Key), new Color(50, 255, 130));
-
-						num = SavedOreTiers.Mythril;
-						break;
-					}
-				default: {
-						if (Main.drunkWorld) {
-							if (SavedOreTiers.Cobalt == 107)
-								SavedOreTiers.Cobalt = 221;
-							else if (SavedOreTiers.Cobalt == 221)
 								SavedOreTiers.Cobalt = 107;
+								if (genRand.Next(2) == 0)
+									SavedOreTiers.Cobalt = 221;
+							}
+
+							int num6 = 12;
+							if (SavedOreTiers.Cobalt == 221) {
+								num6 += 9;
+								num3 *= 0.9f;
+							}
+
+							if (Main.netMode == 0)
+								Main.NewText(Lang.misc[num6].Value, 50, byte.MaxValue, 130);
+							else if (Main.netMode == 2)
+								ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num6].Key), new Color(50, 255, 130));
+
+							num = SavedOreTiers.Cobalt;
+							num3 *= 1.05f;
+							break;
+						}
+					case 1: {
+							if (Main.drunkWorld) {
+								if (SavedOreTiers.Mythril == 108)
+									SavedOreTiers.Mythril = 222;
+								else if (SavedOreTiers.Mythril == 222)
+									SavedOreTiers.Mythril = 108;
+							}
+
+							if (SavedOreTiers.Mythril == -1) {
+								flag = true;
+								SavedOreTiers.Mythril = 108;
+								if (genRand.Next(2) == 0)
+									SavedOreTiers.Mythril = 222;
+							}
+
+							int num7 = 13;
+							if (SavedOreTiers.Mythril == 222) {
+								num7 += 9;
+								num3 *= 0.9f;
+							}
+
+							if (Main.netMode == 0)
+								Main.NewText(Lang.misc[num7].Value, 50, byte.MaxValue, 130);
+							else if (Main.netMode == 2)
+								ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num7].Key), new Color(50, 255, 130));
+
+							num = SavedOreTiers.Mythril;
+							break;
+						}
+					default: {
+							if (Main.drunkWorld) {
+								if (SavedOreTiers.Cobalt == 107)
+									SavedOreTiers.Cobalt = 221;
+								else if (SavedOreTiers.Cobalt == 221)
+									SavedOreTiers.Cobalt = 107;
-						}
+							}
 
-						if (SavedOreTiers.Adamantite == -1) {
+							if (SavedOreTiers.Adamantite == -1) {
-							flag = true;
+								flag = true;
-							SavedOreTiers.Adamantite = 111;
+								SavedOreTiers.Adamantite = 111;
-							if (genRand.Next(2) == 0)
+								if (genRand.Next(2) == 0)
-								SavedOreTiers.Adamantite = 223;
+									SavedOreTiers.Adamantite = 223;
-						}
+							}
 
-						int num5 = 14;
+							int num5 = 14;
-						if (SavedOreTiers.Adamantite == 223) {
+							if (SavedOreTiers.Adamantite == 223) {
-							num5 += 9;
+								num5 += 9;
-							num3 *= 0.9f;
+								num3 *= 0.9f;
-						}
+							}
 
-						if (Main.netMode == 0)
+							if (Main.netMode == 0)
-							Main.NewText(Lang.misc[num5].Value, 50, byte.MaxValue, 130);
+								Main.NewText(Lang.misc[num5].Value, 50, byte.MaxValue, 130);
-						else if (Main.netMode == 2)
+							else if (Main.netMode == 2)
-							ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num5].Key), new Color(50, 255, 130));
+								ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num5].Key), new Color(50, 255, 130));
 
-						num = SavedOreTiers.Adamantite;
+							num = SavedOreTiers.Adamantite;
-						break;
+							break;
-					}
+						}
-			}
+				}
 
-			if (flag)
+				if (flag)
-				NetMessage.SendData(7);
+					NetMessage.SendData(7);
+			}));
 
+			altarTasks.Add(new PassLegacy("Altar Spawn Ore", (progress, config) => {
-			for (int k = 0; (float)k < num3; k++) {
+				for (int k = 0; (float)k < num3; k++) {
-				int i2 = genRand.Next(100, Main.maxTilesX - 100);
+					int i2 = genRand.Next(100, Main.maxTilesX - 100);
-				double num8 = Main.worldSurface;
+					double num8 = Main.worldSurface;
-				if (num == 108 || num == 222)
+					if (num == 108 || num == 222)
-					num8 = Main.rockLayer;
+						num8 = Main.rockLayer;
 
-				if (num == 111 || num == 223)
+					if (num == 111 || num == 223)
-					num8 = (Main.rockLayer + Main.rockLayer + (double)Main.maxTilesY) / 3.0;
+						num8 = (Main.rockLayer + Main.rockLayer + (double)Main.maxTilesY) / 3.0;
 
-				int j2 = genRand.Next((int)num8, Main.maxTilesY - 150);
+					int j2 = genRand.Next((int)num8, Main.maxTilesY - 150);
-				OreRunner(i2, j2, genRand.Next(5, 9 + num4), genRand.Next(5, 9 + num4), (ushort)num);
+					OreRunner(i2, j2, genRand.Next(5, 9 + num4), genRand.Next(5, 9 + num4), (ushort)num);
-			}
+				}
+			}));
 
+			altarTasks.Add(new PassLegacy("Altar Convert Stone", (progress, config) => {
-			int num9 = genRand.Next(3);
+				int num9 = genRand.Next(3);
-			int num10 = 0;
+				int num10 = 0;
-			while (num9 != 2 && num10++ < 1000) {
+				while (num9 != 2 && num10++ < 1000) {
-				int num11 = genRand.Next(100, Main.maxTilesX - 100);
+					int num11 = genRand.Next(100, Main.maxTilesX - 100);
-				int num12 = genRand.Next((int)Main.rockLayer + 50, Main.maxTilesY - 300);
+					int num12 = genRand.Next((int)Main.rockLayer + 50, Main.maxTilesY - 300);
-				if (!Main.tile[num11, num12].active() || Main.tile[num11, num12].type != 1)
+					if (!Main.tile[num11, num12].active() || Main.tile[num11, num12].type != 1)
-					continue;
+						continue;
 
-				if (num9 == 0) {
+					if (num9 == 0) {
-					if (crimson)
+						if (crimson)
-						Main.tile[num11, num12].type = 203;
+							Main.tile[num11, num12].type = 203;
-					else
+						else
-						Main.tile[num11, num12].type = 25;
+							Main.tile[num11, num12].type = 25;
-				}
+					}
-				else {
+					else {
-					Main.tile[num11, num12].type = 117;
+						Main.tile[num11, num12].type = 117;
-				}
+					}
 
-				if (Main.netMode == 2)
+					if (Main.netMode == 2)
-					NetMessage.SendTileSquare(-1, num11, num12, 1);
+						NetMessage.SendTileSquare(-1, num11, num12, 1);
 
-				break;
+					break;
-			}
+				}
+			}));
 
-			if (Main.netMode != 1) {
-				int num13 = Main.rand.Next(2) + 1;
-				for (int l = 0; l < num13; l++) {
-					NPC.SpawnOnPlayer(Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16), 82);
-				}
+			altarTasks.Add(new PassLegacy("Altar Spawn Wraith", (progress, config) => {
+				if (Main.netMode != 1) {
+					int num13 = Main.rand.Next(2) + 1;
+					for (int l = 0; l < num13; l++) {
+						NPC.SpawnOnPlayer(Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16), 82);
+					}
+				}
+			}));
+
+			WorldHooks.ModifyAltarTasks(altarTasks);
+			foreach (GenPass task in altarTasks) {
+				task.Apply(null, null);
 			}
 
 			altarCount++;
@@ -29268,7 +_,7 @@
 				if (!Main.tile[k, j].active() || Main.tile[k, j].type != type || Main.tile[k, j].frameX != (k - num) * 18 + num3 || Main.tile[k, j].frameY != 0)
 					flag = true;
 
-				if (Main.tile[k, j - 1].active() && (TileID.Sets.BasicChest[Main.tile[k, j - 1].type] || TileID.Sets.BasicChestFake[Main.tile[k, j - 1].type] || Main.tile[k, j - 1].type == 88 || Main.tile[k, j - 1].type == 470 || Main.tile[k, j - 1].type == 475 || Main.tile[k, j - 1].type == 597))
+				if (Main.tile[k, j - 1].active() && (TileID.Sets.BasicChest[Main.tile[k, j - 1].type] || TileID.Sets.BasicChestFake[Main.tile[k, j - 1].type] || TileID.Sets.BasicDresser[Main.tile[k, j - 1].type]  || Main.tile[k, j - 1].type == 470 || Main.tile[k, j - 1].type == 475 || Main.tile[k, j - 1].type == 597))
 					return;
 
 				if (!SolidTileAllowBottomSlope(k, j + 1))
@@ -29280,7 +_,7 @@
 
 			_ = Main.tile[i, j].frameX;
 			destroyObject = true;
-			if (type == 235)
+			if (TileLoader.Drop(i, j, type) && type == 235)
 				Item.NewItem(i * 16, j * 16, 32, 32, 1263);
 
 			for (int l = num; l < num + 3; l++) {
@@ -29433,6 +_,9 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
+				
 			if (type == 14) {
 				int type2;
 				if (num6 >= 1 && num6 <= 3) {
@@ -29875,6 +_,7 @@
 					break;
 			}
 
+			skipDrop:
 			destroyObject = false;
 			for (int num12 = num5 - 1; num12 < num5 + 4; num12++) {
 				for (int num13 = num - 1; num13 < num + 4; num13++) {
@@ -29886,7 +_,7 @@
 				mysticLogsEvent.FallenLogDestroyed();
 		}
 
-		private static int GetDresserItemDrop(int style) {
+		public static int GetDresserItemDrop(int style) {
 			if (style >= 1 && style <= 3)
 				return 646 + style;
 
@@ -30011,6 +_,9 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
+
 			switch (type) {
 				case 101: {
 						int type3;
@@ -30154,6 +_,7 @@
 					}
 			}
 
+			skipDrop:
 			destroyObject = false;
 			for (int num7 = num - 1; num7 < num + 4; num7++) {
 				for (int num8 = num2 - 1; num8 < num2 + 4; num8++) {
@@ -30204,12 +_,16 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
+
 			if (type == 464)
 				Item.NewItem(i * 16, j * 16, 32, 32, 3814);
 
 			if (type == 466)
 				Item.NewItem(i * 16, j * 16, 32, 32, 3816);
 
+			skipDrop:
 			destroyObject = false;
 			for (int num5 = num - 1; num5 < num + 6; num5++) {
 				for (int num6 = num2 - 1; num6 < num2 + 5; num6++) {
@@ -30255,6 +_,9 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
+
 			if (type == 275)
 				Item.NewItem(i * 16, j * 16, 32, 32, 2162);
 
@@ -30360,6 +_,7 @@
 			if (type == 612)
 				Item.NewItem(i * 16, j * 16, 32, 32, 4895);
 
+			skipDrop:
 			destroyObject = false;
 			for (int num4 = num - 1; num4 < num + 7; num4++) {
 				for (int num5 = num2 - 1; num5 < num2 + 4; num5++) {
@@ -30655,6 +_,9 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
+
 			int type2 = 928;
 			switch (num2) {
 				case 1:
@@ -30670,6 +_,7 @@
 			}
 
 			Item.NewItem(i * 16, j * 16, 32, 32, type2);
+			skipDrop:
 			destroyObject = false;
 			for (int num7 = num; num7 < num + 4; num7++) {
 				for (int num8 = num3; num8 < num3 + 3; num8++) {
@@ -30771,7 +_,8 @@
 					if (Main.tile[k, l] == null)
 						Main.tile[k, l] = new Tile();
 
-					if (Main.tile[k, l].active() && (Main.tile[k, l].type == 139 || Main.tile[k, l].type == 35)) {
+					if (Main.tile[k, l].active() && (Main.tile[k, l].type == 139 || Main.tile[k, l].type == 35
+						|| TileLoader.IsModMusicBox(Main.tile[k, l]))) {
 						if (Main.tile[k, l].frameX < 36)
 							Main.tile[k, l].frameX += 36;
 						else
@@ -30933,6 +_,9 @@
 				}
 			}
 
+			// size ???
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
 			if (type == 35)
 				Item.NewItem(i * 16, j * 16, 32, 32, 1813);
 			else if (num3 == 28)
@@ -31056,6 +_,7 @@
 			else
 				Item.NewItem(i * 16, j * 16, 32, 32, 562 + num3);
 
+			skipDrop:
 			for (int num7 = num - 1; num7 < num + 3; num7++) {
 				for (int num8 = num2 - 1; num8 < num2 + 3; num8++) {
 					TileFrame(num7, num8);
@@ -31181,9 +_,6 @@
 		}
 
 		public static bool PlaceObject(int x, int y, int type, bool mute = false, int style = 0, int alternate = 0, int random = -1, int direction = -1) {
-			if (type >= 624)
-				return false;
-
 			if (!TileObject.CanPlace(x, y, type, style, direction, out TileObject objectData))
 				return false;
 
@@ -31357,7 +_,9 @@
 			if (point.Y == 0)
 				type2 = 3239;
 
+			if (TileLoader.Drop(x, y, type))
-			Item.NewItem(x * 16, y * 16, num * 16, num2 * 16, type2);
+				Item.NewItem(x * 16, y * 16, num * 16, num2 * 16, type2);
+
 			for (int k = x - 1; k < x + num + 1; k++) {
 				for (int l = y - 1; l < y + num2 + 1; l++) {
 					TileFrame(k, l);
@@ -31410,7 +_,9 @@
 			if (point.Y == 0)
 				type2 = 3240;
 
+			if (TileLoader.Drop(x, y, type))
-			Item.NewItem(x * 16, y * 16, width * 16, height * 16, type2);
+				Item.NewItem(x * 16, y * 16, width * 16, height * 16, type2);
+
 			for (int m = x - 1; m < x + width + 1; m++) {
 				for (int n = y - 1; n < y + height + 1; n++) {
 					TileFrame(m, n);
@@ -31753,7 +_,7 @@
 				}
 			}
 
-			if (type == 88) {
+			if (TileID.Sets.BasicDresser[type]) {
 				if (Chest.CreateChest(x - 1, y - 1) == -1)
 					flag2 = false;
 				else if (Main.netMode == 1)
@@ -31930,6 +_,9 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
+
 			switch (type) {
 				case 254:
 					if (frameX < 72)
@@ -32138,6 +_,7 @@
 					}
 			}
 
+			skipDrop:
 			destroyObject = false;
 			for (int num8 = num3 - 1; num8 < num3 + 3; num8++) {
 				for (int num9 = num - 1; num9 < num + 3; num9++) {
@@ -32501,6 +_,8 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
 			if (type == 454) {
 				switch (Main.rand.Next(9)) {
 					case 2:
@@ -32703,6 +_,7 @@
 				Item.NewItem(i * 16, j * 16, 32, 32, type2);
 			}
 
+			skipDrop:
 			destroyObject = false;
 			for (int num19 = num - 1; num19 < num + num3 + 1; num19++) {
 				for (int num20 = num2 - 1; num20 < num2 + 4; num20++) {
@@ -32774,6 +_,9 @@
 				}
 			}
 
+			if (!TileLoader.Drop(num, j, type))
+				goto skipDrop;
+
 			switch (type) {
 				case 106:
 					Item.NewItem(i * 16, j * 16, 32, 32, 363);
@@ -32869,6 +_,7 @@
 					break;
 			}
 
+			skipDrop:
 			destroyObject = false;
 			for (int num16 = num - 1; num16 < num + 4; num16++) {
 				for (int num17 = num2 - 1; num17 < num2 + 4; num17++) {
@@ -33469,7 +_,7 @@
 				}
 			}
 
-			if (!Main.tile[num2, num].nactive() || Main.tile[num2, num].halfBrick() || Main.tile[num2, num].slope() != 0 || (Main.tile[num2, num].type != 53 && Main.tile[num2, num].type != 112 && Main.tile[num2, num].type != 116 && Main.tile[num2, num].type != 234)) {
+			if (!Main.tile[num2, num].nactive() || Main.tile[num2, num].halfBrick() || Main.tile[num2, num].slope() != 0 || Main.tile[num2, num].type != 53 && Main.tile[num2, num].type != 112 && Main.tile[num2, num].type != 116 && Main.tile[num2, num].type != 234 && !TileLoader.CanGrowModCactus(Main.tile[num2, num].type)) {
 				KillTile(i, j);
 				return true;
 			}
@@ -33480,7 +_,7 @@
 					return true;
 				}
 			}
-			else if (i == num2 && (!Main.tile[i, j + 1].active() || (Main.tile[i, j + 1].type != 80 && Main.tile[i, j + 1].type != 53 && Main.tile[i, j + 1].type != 112 && Main.tile[i, j + 1].type != 116 && Main.tile[i, j + 1].type != 234))) {
+			else if (i == num2 && (!Main.tile[i, j + 1].active() || Main.tile[i, j + 1].type != 80 && Main.tile[i, j + 1].type != 53 && Main.tile[i, j + 1].type != 112 && Main.tile[i, j + 1].type != 116 && Main.tile[i, j + 1].type != 234 && !TileLoader.CanGrowModCactus(Main.tile[i, j + 1].type))) {
 				KillTile(i, j);
 				return true;
 			}
@@ -33541,7 +_,7 @@
 				}
 			}
 
-			if (Main.netMode != 1 && !noTileActions) {
+			if (Main.netMode != 1 && !noTileActions && TileLoader.Drop(num, num2, type)) {
 				switch (type) {
 					case 12:
 						Item.NewItem(num * 16, num2 * 16, 32, 32, 29);
@@ -33669,6 +_,9 @@
 			if (num2 == 112)
 				num2 = 53;
 
+			if (TileLoader.CanGrowModPalmTree(num2))
+				num2 = 53;
+
 			if (num2 != 53 && num2 != type)
 				KillTile(i, j);
 
@@ -34052,6 +_,9 @@
 			if (num4 == 492)
 				num4 = 2;
 
+			if (TileLoader.CanGrowModTree(num4))
+				num4 = 2;
+
 			if (num4 != 2 && num4 != type && ((Main.tile[i, j].frameX == 0 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 22 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 44 && Main.tile[i, j].frameY <= 130)))
 				KillTile(i, j);
 
@@ -34346,7 +_,7 @@
 					int wall = Main.tile[k, l].wall;
 					switch (conversionType) {
 						case 4:
-							if (type <= 624 && wall <= 316) {
+							if (true) { //if (type <= X && wall <= X) {
 								if (WallID.Sets.Conversion.Grass[wall] && wall != 81) {
 									Main.tile[k, l].wall = 81;
 									SquareWallFrame(k, l);
@@ -34432,8 +_,6 @@
 							}
 							continue;
 						case 2:
-							if (type > 624 || wall > 316)
-								continue;
 							if (WallID.Sets.Conversion.Grass[wall] && wall != 70) {
 								Main.tile[k, l].wall = 70;
 								SquareWallFrame(k, l);
@@ -34521,7 +_,7 @@
 							}
 							continue;
 						case 1:
-							if (type <= 624 && wall <= 316) {
+							if (true) { //if (type <= X && wall <= X) {
 								if (WallID.Sets.Conversion.Grass[wall] && wall != 69) {
 									Main.tile[k, l].wall = 69;
 									SquareWallFrame(k, l);
@@ -34941,7 +_,7 @@
 			if (num3 / 255 > cactusWaterLimit)
 				return;
 
-			if (Main.tile[i, j].type == 53 || Main.tile[i, j].type == 112 || Main.tile[i, j].type == 116 || Main.tile[i, j].type == 234) {
+			if (Main.tile[i, j].type == 53 || Main.tile[i, j].type == 112 || Main.tile[i, j].type == 116 || Main.tile[i, j].type == 234 || TileLoader.CanGrowModCactus(Main.tile[i, j].type)) {
 				if (Main.tile[i, j - 1].active() || Main.tile[i - 1, j - 1].active() || Main.tile[i + 1, j - 1].active())
 					return;
 
@@ -34959,7 +_,7 @@
 									return;
 							}
 
-							if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 112 || Main.tile[m, n].type == 116 || Main.tile[m, n].type == 234)
+							if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 112 || Main.tile[m, n].type == 116 || Main.tile[m, n].type == 234 || TileLoader.CanGrowModCactus(Main.tile[m, n].type))
 								num5++;
 						}
 						catch {
@@ -35127,6 +_,10 @@
 			if (!flag)
 				return;
 
+			// size ???
+			if (!TileLoader.Drop(num, num2, type))
+				goto skipDrop;
+
 			destroyObject = true;
 			if (num4 >= 7 && num4 <= 9)
 				SoundEngine.PlaySound(6, i * 16, j * 16);
@@ -35635,6 +_,7 @@
 				}
 			}
 
+			skipDrop:
 			destroyObject = false;
 		}
 
@@ -35663,6 +_,9 @@
 			if (num != -1 && Main.netMode == 1 && type == 467)
 				NetMessage.SendData(34, -1, -1, null, 4, x, y, style);
 
+			if (num != 1 && Main.netMode == 1 && type >= TileID.Count && TileID.Sets.BasicChest[type])
+				NetMessage.SendData(34, -1, -1, null, 100, x, y, style, 0, type, 0);
+
 			return num;
 		}
 
@@ -35786,7 +_,7 @@
 			destroyObject = false;
 		}
 
-		private static int GetChestItemDrop(int x, int y, int type) {
+		public static int GetChestItemDrop(int x, int y, int type) {
 			int num = Main.tile[x, y].frameX / 36;
 			if (type == 467)
 				return Chest.chestItemSpawn2[num];
@@ -35948,7 +_,7 @@
 			return false;
 		}
 
-		private static bool SeaOatWaterCheck(int x, int y) {
+		public static bool SeaOatWaterCheck(int x, int y) {
 			int num = 45;
 			int num2 = 20;
 			int num3 = 20;
@@ -35987,7 +_,7 @@
 			return false;
 		}
 
-		private static bool PlantSeaOat(int x, int y) {
+		public static bool PlantSeaOat(int x, int y) {
 			if (Main.tile[x, y].wall > 0 || Main.tile[x, y].active() || Main.tile[x, y].liquid > 0 || !SolidTileAllowBottomSlope(x, y + 1) || !TileID.Sets.Conversion.Sand[Main.tile[x, y + 1].type])
 				return false;
 
@@ -36007,7 +_,7 @@
 			return true;
 		}
 
-		private static bool CheckSeaOat(int x, int y) {
+		public static bool CheckSeaOat(int x, int y) {
 			if (!SeaOatWaterCheck(x, y)) {
 				KillTile(x, y);
 				if (Main.netMode == 2)
@@ -36019,7 +_,7 @@
 			return true;
 		}
 
-		private static bool GrowSeaOat(int x, int y) {
+		public static bool GrowSeaOat(int x, int y) {
 			if (Main.tile[x, y].frameX < 180)
 				Main.tile[x, y].frameX += 90;
 
@@ -36029,7 +_,7 @@
 			return false;
 		}
 
-		private static int GetWaterDepth(int x, int y) {
+		public static int GetWaterDepth(int x, int y) {
 			int num = y;
 			while (!SolidTile(x, num)) {
 				num++;
@@ -36046,7 +_,7 @@
 			return num - num2;
 		}
 
-		private static int CountGrowingPlantTiles(int x, int y, int range, int type) {
+		public static int CountGrowingPlantTiles(int x, int y, int range, int type) {
 			int num = 0;
 			for (int i = x - range; i <= x + range; i++) {
 				for (int j = y - range * 3; j <= y + range * 3; j++) {
@@ -36058,7 +_,7 @@
 			return num;
 		}
 
-		private static bool PlaceBamboo(int x, int y) {
+		public static bool PlaceBamboo(int x, int y) {
 			int num = 2;
 			int num2 = 5;
 			int num3 = genRand.Next(1, 21);
@@ -36773,9 +_,6 @@
 			if (gen && Main.tile[i, j].active() && Main.tile[i, j].type == 488)
 				return false;
 
-			if (num >= 624)
-				return false;
-
 			bool result = false;
 			if (i >= 0 && j >= 0 && i < Main.maxTilesX && j < Main.maxTilesY) {
 				Tile tile = Main.tile[i, j];
@@ -36852,7 +_,7 @@
 									return false;
 								break;
 							case 3:
-							case 20:
+							case int _ when TileID.Sets.TreeSapling[num]:
 							case 24:
 							case 27:
 							case 32:
@@ -37091,7 +_,7 @@
 							SquareTileFrame(i, j);
 						}
 					}
-					else if (num == 4) {
+					else if (TileID.Sets.Torch[num]) {
 						if (Main.tile[i - 1, j] == null)
 							Main.tile[i - 1, j] = new Tile();
 
@@ -37226,7 +_,7 @@
 							case 26:
 							case 86:
 							case 87:
-							case 88:
+							case int _ when TileID.Sets.BasicDresser[num]:
 							case 89:
 							case 114:
 							case 186:
@@ -37247,13 +_,15 @@
 								PlaceJunglePlant(i, j, (ushort)num, 0, 0);
 								SquareTileFrame(i, j);
 								break;
-							case 20: {
+							case int _ when TileID.Sets.TreeSapling[num]: {
 									if (Main.tile[i, j + 1] == null)
 										Main.tile[i, j + 1] = new Tile();
 
 									int type = Main.tile[i, j + 1].type;
+									int dummyType = TileID.Saplings;
+									int dummyStyle = 0;
-									if (Main.tile[i, j + 1].active() && (type == 2 || type == 109 || type == 147 || type == 60 || type == 23 || type == 199 || type == 53 || type == 234 || type == 116 || type == 112)) {
+									if (Main.tile[i, j + 1].active() && (type == 2 || type == 109 || type == 147 || type == 60 || type == 23 || type == 199 || type == 53 || type == 234 || type == 116 || type == 112 || TileLoader.SaplingGrowthType(type, ref dummyType, ref dummyStyle))) {
-										Place1x2(i, j, (ushort)num, style);
+										Place1x2(i, j, (ushort)dummyType, dummyStyle);
 										SquareTileFrame(i, j);
 									}
 
@@ -37448,6 +_,9 @@
 											case 314:
 												Minecart.PlaceTrack(tile, style);
 												break;
+											case int _ when num >= TileID.Count && TileObjectData.GetTileData(num, style) != null:
+												PlaceObject(i, j, (ushort)num, mute, style);
+												break;
 											default:
 												tile.active(active: true);
 												tile.type = (ushort)num;
@@ -37511,11 +_,13 @@
 				return;
 
 			fail = KillWall_CheckFailure(fail, tile);
+			WallLoader.KillWall(i, j, tile.type, ref fail);
 			KillWall_PlaySounds(i, j, tile);
 			int num = 10;
 			if (fail)
 				num = 3;
 
+			WallLoader.NumDust(i, j, tile.wall, fail, ref num);
 			for (int k = 0; k < num; k++) {
 				KillWall_MakeWallDust(i, j, tile);
 			}
@@ -37529,11 +_,11 @@
 			tile.wall = 0;
 			tile.wallColor(0);
 			SquareWallFrame(i, j);
-			if (tile.type >= 0 && tile.type < 624 && TileID.Sets.FramesOnKillWall[tile.type])
+			if (tile.type >= 0 && TileID.Sets.FramesOnKillWall[tile.type])
 				TileFrame(i, j);
 		}
 
-		private static bool KillWall_CheckFailure(bool fail, Tile tileCache) {
+		public static bool KillWall_CheckFailure(bool fail, Tile tileCache) {
 			if (Main.wallDungeon[tileCache.wall] && !NPC.downedBoss3)
 				fail = true;
 
@@ -37543,7 +_,10 @@
 			return fail;
 		}
 
-		private static void KillWall_PlaySounds(int i, int j, Tile tileCache) {
+		public static void KillWall_PlaySounds(int i, int j, Tile tileCache) {
+			if (!WallLoader.KillSound(i,j,tileCache.wall))
+				return;
+
 			if (tileCache.wall == 241 || (tileCache.wall >= 88 && tileCache.wall <= 93) || tileCache.wall == 21 || tileCache.wall == 186 || tileCache.wall == 136 || tileCache.wall == 137 || tileCache.wall == 168 || tileCache.wall == 169 || tileCache.wall == 172 || tileCache.wall == 226 || tileCache.wall == 227 || tileCache.wall == 242 || tileCache.wall == 243)
 				SoundEngine.PlaySound(13, i * 16, j * 16);
 			else if ((tileCache.wall >= 63 && tileCache.wall <= 70) || tileCache.wall == 264 || tileCache.wall == 268 || tileCache.wall == 265)
@@ -37552,13 +_,14 @@
 				SoundEngine.PlaySound(0, i * 16, j * 16);
 		}
 
-		private static void KillWall_DropItems(int i, int j, Tile tileCache) {
+		public static void KillWall_DropItems(int i, int j, Tile tileCache) {
 			int num = KillWall_GetItemDrops(tileCache);
-			if (num > 0)
+
+			if (WallLoader.Drop(i, j, Main.tile[i,j].wall, ref num) && num > 0)
 				Item.NewItem(i * 16, j * 16, 16, 16, num);
 		}
 
-		private static int KillWall_GetItemDrops(Tile tileCache) {
+		public static int KillWall_GetItemDrops(Tile tileCache) {
 			switch (tileCache.wall) {
 				case 237:
 					return 4233;
@@ -38118,13 +_,13 @@
 
 						if (tileCache.wall >= 138 && tileCache.wall <= 141)
 							result = 2210 + tileCache.wall - 138;
-
+						
 						return result;
 					}
 			}
 		}
 
-		private static void KillWall_MakeWallDust(int i, int j, Tile tileCache) {
+		public static void KillWall_MakeWallDust(int i, int j, Tile tileCache) {
 			int num = 0;
 			switch (tileCache.wall) {
 				case 7:
@@ -38679,6 +_,9 @@
 			if (tileCache.wall == 245)
 				num = 195;
 
+			if (!WallLoader.CreateDust(i, j, tileCache.wall, ref num))
+				return;
+
 			if (tileCache.wall == 44) {
 				int num2 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 66, 0f, 0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
 				Main.dust[num2].noGravity = true;
@@ -38759,6 +_,9 @@
 			if (!tile.active())
 				return false;
 
+			if (!TileLoader.CanKillTile(i, j, tile.type, ref blockDamaged))
+				return false;
+
 			if (j >= 1)
 				tile2 = Main.tile[i, j - 1];
 
@@ -38772,6 +_,7 @@
 						if (tile.type != type && (tile2.frameX == 66 || tile2.frameX == 220))
 							return false;
 						break;
+					case int _ when TileID.Sets.BasicDresser[type]:
 					case 21:
 					case 26:
 					case 72:
@@ -38822,6 +_,7 @@
 					if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 2, j - tile.frameY / 18))
 						return false;
 					break;
+				case ushort _ when TileID.Sets.BasicDresser[tile.type]:
 				case 88:
 					if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 3, j - tile.frameY / 18))
 						return false;
@@ -38945,7 +_,7 @@
 					return true;
 			}
 
-			if (tile.type == 88) {
+			if (TileID.Sets.BasicDresser[tile.type]) {
 				int num2 = tile.frameX / 18;
 				int y3 = y - tile.frameY / 18;
 				num2 %= 3;
@@ -38964,7 +_,7 @@
 		}
 
 		public static bool ReplaceWall(int x, int y, ushort targetWall) {
-			if (targetWall >= 316)
+			if (targetWall >= WallLoader.WallCount)
 				return false;
 
 			Tile tile = Main.tile[x, y];
@@ -38996,7 +_,7 @@
 				return false;
 
 			MoveReplaceTileAnchor(ref x, ref y, targetType, tileSafely);
-			int num = KillTile_GetTileDustAmount(fail: false, tileSafely);
+			int num = KillTile_GetTileDustAmount(false, tileSafely, x, y);
 			for (int i = 0; i < num; i++) {
 				KillTile_MakeTileDust(x, y, tileSafely);
 			}
@@ -39008,7 +_,7 @@
 			return true;
 		}
 
-		private static void ReplaceTIle_DoActualReplacement(ushort targetType, int targetStyle, int topLeftX, int topLeftY, Tile t) {
+		public static void ReplaceTIle_DoActualReplacement(ushort targetType, int targetStyle, int topLeftX, int topLeftY, Tile t) {
 			if (TileID.Sets.BasicChest[targetType]) {
 				if (IsChestRigged(topLeftX, topLeftY) && Main.netMode != 1) {
 					Wiring.HitSwitch(topLeftX, topLeftY);
@@ -39025,7 +_,7 @@
 			}
 		}
 
-		private static void ReplaceTile_DoActualReplacement_Single(ushort targetType, int targetStyle, int topLeftX, int topLeftY, Tile t) {
+		public static void ReplaceTile_DoActualReplacement_Single(ushort targetType, int targetStyle, int topLeftX, int topLeftY, Tile t) {
 			ReplaceTile_EliminateNaturalExtras(topLeftX, topLeftY);
 			int type = t.type;
 			t.type = targetType;
@@ -39045,7 +_,7 @@
 			SquareTileFrame(topLeftX, topLeftY);
 		}
 
-		private static void ReplaceTile_EliminateNaturalExtras(int x, int y) {
+		public static void ReplaceTile_EliminateNaturalExtras(int x, int y) {
 			if (InWorld(x, y, 2)) {
 				if (Main.tile[x, y - 1] != null && Main.tile[x, y - 1].active() && (TileID.Sets.ReplaceTileBreakUp[Main.tile[x, y - 1].type] || (Main.tile[x, y - 1].type == 165 && (Main.tile[x, y - 1].frameY == 36 || Main.tile[x, y - 1].frameY == 54 || Main.tile[x, y - 1].frameY == 90))))
 					KillTile(x, y - 1);
@@ -39055,7 +_,7 @@
 			}
 		}
 
-		private static void ReplaceTile_DoActualReplacement_Area(ushort targetType, int targetStyle, int topLeftX, int topLeftY, int areaSizeX, int areaSizeY) {
+		public static void ReplaceTile_DoActualReplacement_Area(ushort targetType, int targetStyle, int topLeftX, int topLeftY, int areaSizeX, int areaSizeY) {
 			for (int i = 0; i < areaSizeX; i++) {
 				for (int j = 0; j < areaSizeY; j++) {
 					Tile tile = Main.tile[topLeftX + i, topLeftY + j];
@@ -39073,7 +_,7 @@
 			}
 		}
 
-		private static void MoveReplaceTileAnchor(ref int x, ref int y, ushort targetType, Tile t) {
+		public static void MoveReplaceTileAnchor(ref int x, ref int y, ushort targetType, Tile t) {
 			if (TileID.Sets.BasicChest[t.type]) {
 				x -= t.frameX % 36 / 18;
 				y -= t.frameY % 36 / 18;
@@ -39107,21 +_,21 @@
 			bool flag = !ReplaceTile_IsValidSolid(attemptingToReplaceWith) || !ReplaceTile_IsValidSolid(tile.type);
 			bool num = !ReplaceTile_IsValidPlatform(attemptingToReplaceWith) || !ReplaceTile_IsValidPlatform(tile.type);
 			bool flag2 = (!ReplaceTile_IsValidSolid(attemptingToReplaceWith) && !ReplaceTile_IsValidPlatform(attemptingToReplaceWith)) || (!ReplaceTile_IsValidSolid(tile.type) && !ReplaceTile_IsValidPlatform(tile.type));
-			bool flag3 = !ReplaceTile_IsValidChest(attemptingToReplaceWith) || !ReplaceTile_IsValidChest(tile.type) || Chest.IsLocked(tile);
+			bool flag3 = !ReplaceTile_IsValidChest(attemptingToReplaceWith) || !ReplaceTile_IsValidChest(tile.type) || Chest.IsLocked(x, y, tile);
 			bool flag4 = !ReplaceTile_IsValidDresser(attemptingToReplaceWith) || !ReplaceTile_IsValidDresser(tile.type);
 			return !(num && flag && flag2 && flag3 && flag4);
 		}
 
-		private static bool ReplaceTile_IsValidSolid(int type) {
+		public static bool ReplaceTile_IsValidSolid(int type) {
 			if (Main.tileSolid[type] && !Main.tileSolidTop[type])
 				return !Main.tileFrameImportant[type];
 
 			return false;
 		}
 
-		private static bool ReplaceTile_IsValidChest(int type) => TileID.Sets.BasicChest[type];
+		public static bool ReplaceTile_IsValidChest(int type) => TileID.Sets.BasicChest[type];
-		private static bool ReplaceTile_IsValidDresser(int type) => TileID.Sets.BasicDresser[type];
+		public static bool ReplaceTile_IsValidDresser(int type) => TileID.Sets.BasicDresser[type];
-		private static bool ReplaceTile_IsValidPlatform(int type) => TileID.Sets.Platforms[type];
+		public static bool ReplaceTile_IsValidPlatform(int type) => TileID.Sets.Platforms[type];
 
 		public static bool GetVanityTreeFoliageData(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight) {
 			Tile tile = Main.tile[i, j];
@@ -39367,7 +_,7 @@
 			return false;
 		}
 
-		private static void ShakeTree(int i, int j) {
+		public static void ShakeTree(int i, int j) {
 			if (numTreeShakes == maxTreeShakes)
 				return;
 
@@ -39622,7 +_,7 @@
 			}
 		}
 
-		private static void GetTreeBottom(int i, int j, out int x, out int y) {
+		public static void GetTreeBottom(int i, int j, out int x, out int y) {
 			x = i;
 			y = j;
 			Tile tileSafely = Framing.GetTileSafely(x, y);
@@ -39657,7 +_,7 @@
 			}
 		}
 
-		private static void AttemptFossilShattering(int i, int j, Tile tileCache, bool fail) {
+		public static void AttemptFossilShattering(int i, int j, Tile tileCache, bool fail) {
 			if (tileCache.type != 404 || Main.netMode == 1 || fossilBreak)
 				return;
 
@@ -39704,6 +_,8 @@
 			if (num == 2)
 				return;
 
+			TileLoader.KillTile(i, j, tile.type, ref fail, ref effectOnly, ref noItem); //Placed before gen check on purpose.
+
 			if (gen)
 				noItem = true;
 
@@ -39711,8 +_,10 @@
 				if (!noItem && FixExploitManEaters.SpotProtected(i, j))
 					return;
 
+#if CLIENT
 				if (!gen && !Main.gameMenu)
 					KillTile_PlaySounds(i, j, fail, tile);
+#endif
 			}
 
 			if (tile.type == 128 || tile.type == 269) {
@@ -39845,7 +_,7 @@
 			if ((tile.type == 470 && (CheckTileBreakability2_ShouldTileSurvive(i, j) || fail)) || (tile.type == 475 && (CheckTileBreakability2_ShouldTileSurvive(i, j) || fail)))
 				return;
 
-			int num16 = KillTile_GetTileDustAmount(fail, tile);
+			int num16 = KillTile_GetTileDustAmount(fail, tile, i, j);
 			for (int k = 0; k < num16; k++) {
 				KillTile_MakeTileDust(i, j, tile);
 			}
@@ -40009,9 +_,12 @@
 			}
 		}
 
-		private static Player GetPlayerForTile(int x, int y) => Main.player[Player.FindClosest(new Vector2(x, y) * 16f, 16, 16)];
+		public static Player GetPlayerForTile(int x, int y) => Main.player[Player.FindClosest(new Vector2(x, y) * 16f, 16, 16)];
 
-		private static void KillTile_DropItems(int x, int y, Tile tileCache, bool includeLargeObjectDrops = false) {
+		public static void KillTile_DropItems(int x, int y, Tile tileCache, bool includeLargeObjectDrops = false) {
+			if (!TileLoader.Drop(x, y, Main.tile[x, y].type))
+				return;
+
 			KillTile_GetItemDrops(x, y, tileCache, out int dropItem, out int dropItemStack, out int secondaryItem, out int secondaryItemStack, includeLargeObjectDrops);
 			if (!Main.getGoodWorld || tileCache.active()) {
 				if (dropItem > 0) {
@@ -41847,7 +_,7 @@
 			}
 		}
 
-		private static void SetGemTreeDrops(int gemType, int seedType, Tile tileCache, ref int dropItem, ref int secondaryItem) {
+		public static void SetGemTreeDrops(int gemType, int seedType, Tile tileCache, ref int dropItem, ref int secondaryItem) {
 			if (Main.rand.Next(10) == 0)
 				dropItem = gemType;
 			else
@@ -41857,7 +_,7 @@
 				secondaryItem = seedType;
 		}
 
-		private static void SetVanityTreeDrops(int dropType, Tile tileCache, ref int dropItem) {
+		public static void SetVanityTreeDrops(int dropType, Tile tileCache, ref int dropItem) {
 			if (Main.rand.Next(2) == 0)
 				dropItem = dropType;
 		}
@@ -41888,7 +_,7 @@
 			return result;
 		}
 
-		private static bool KillTile_ShouldDropSeeds(int x, int y) {
+		public static bool KillTile_ShouldDropSeeds(int x, int y) {
 			if (Main.rand.Next(2) == 0) {
 				if (!GetPlayerForTile(x, y).HasItem(281))
 					return GetPlayerForTile(x, y).HasItem(986);
@@ -41899,7 +_,7 @@
 			return false;
 		}
 
-		private static void KillTile_GetTreeDrops(int i, int j, Tile tileCache, ref bool bonusWood, ref int dropItem, ref int secondaryItem) {
+		public static void KillTile_GetTreeDrops(int i, int j, Tile tileCache, ref bool bonusWood, ref int dropItem, ref int secondaryItem) {
 			if (tileCache.frameX >= 22 && tileCache.frameY >= 198) {
 				if (Main.netMode != 1) {
 					if (genRand.Next(2) == 0) {
@@ -41909,7 +_,7 @@
 
 						if (Main.tile[i, k] != null) {
 							Tile tile = Main.tile[i, k];
-							if (tile.type == 2 || tile.type == 109 || tile.type == 477 || tile.type == 492 || tile.type == 147 || tile.type == 199 || tile.type == 23) {
+							if (tile.type == 2 || tile.type == 109 || tile.type == 477 || tile.type == 492 || tile.type == 147 || tile.type == 199 || tile.type == 23 || TileLoader.CanDropAcorn(tile.type)) {
 								dropItem = 9;
 								secondaryItem = 27;
 							}
@@ -41956,6 +_,8 @@
 						dropItem = 2503;
 						break;
 				}
+				TileLoader.DropTreeWood(Main.tile[x,y].type,ref dropItem);
+				TileLoader.DropPalmTreeWood(Main.tile[x,y].type,ref dropItem);
 			}
 
 			int num = Player.FindClosest(new Vector2(x * 16, y * 16), 16, 16);
@@ -41964,7 +_,7 @@
 				bonusWood = true;
 		}
 
-		private static void KillTile_DropBait(int i, int j, Tile tileCache) {
+		public static void KillTile_DropBait(int i, int j, Tile tileCache) {
 			int num = -1;
 			int num2 = -1;
 			int num3 = -1;
@@ -42028,6 +_,7 @@
 			if (Main.player[num4].ZoneGraveyard)
 				num5 = 606;
 
+			TileLoader.DropCritterChance(i,j,tileCache.type,ref num,ref num2,ref num3);
 			if (num > 0 && NPC.CountNPCS(num5) < 5 && genRand.Next(num) == 0) {
 				int type = num5;
 				if (num5 == 357 && Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0f)
@@ -42076,6 +_,10 @@
 				return;
 
 			int type = tileCache.type;
+			
+			if(!TileLoader.KillSound(i,j,type))
+				return;
+
 			if (type == 127 || type == 623) {
 				SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
 			}
@@ -42200,7 +_,14 @@
 			return value;
 		}
 
+		public static int KillTile_GetTileDustAmount(bool fail,Tile tileCache,int x,int y) {
+			int result = KillTile_GetTileDustAmount_Vanilla(fail,tileCache);
+
+			TileLoader.NumDust(x,y,tileCache.type,fail,ref result);
+
+			return result;
+		}
-		public static int KillTile_GetTileDustAmount(bool fail, Tile tileCache) {
+		public static int KillTile_GetTileDustAmount_Vanilla(bool fail, Tile tileCache) {
 			switch (tileCache.type) {
 				default:
 					if (!fail)
@@ -43237,8 +_,11 @@
 						if (Main.tile[num11, k].active() && Main.tile[num11, k].type == 199)
 							num = 121;
 
+						//patch file: num11, k
 						if (Main.tile[num11, k].active() && Main.tile[num11, k].type == 147)
 							num = 122;
+
+						TileLoader.TreeDust(Main.tile[num11, k], ref num);
 					}
 				}
 			}
@@ -43257,8 +_,11 @@
 						if (Main.tile[i, l].active() && Main.tile[i, l].type == 116)
 							num = 79;
 
+						//patch file: l
 						if (Main.tile[i, l].active() && Main.tile[i, l].type == 112)
 							num = 77;
+
+						TileLoader.PalmTreeDust(Main.tile[i, l], ref num);
 					}
 				}
 			}
@@ -43867,7 +_,7 @@
 			if (type == 178 || (uint)(type - 426) <= 1u || (uint)(type - 430) <= 10u)
 				flag = true;
 
-			if (num >= 0) {
+			if (TileLoader.CreateDust(i,j,tileCache.type,ref num) && num >= 0) {
 				if (tileCache.type == 518) {
 					int num14 = (int)tileCache.liquid / 16;
 					num14 -= 3;
@@ -43958,6 +_,10 @@
 			if (t.type == 10 && t.frameY >= 594 && t.frameY <= 646)
 				return t.frameX < 54;
 
+			// something might be meant to go here but it's not this - Chicken Bones (I don't know what a "locked door" even is)
+			//if (TileLoader.OpenDoorID(t) < 0)
+			//	return true;
+
 			return false;
 		}
 
@@ -44140,7 +_,7 @@
 			return true;
 		}
 
-		private static bool nearbyChlorophyte(int i, int j) {
+		public static bool nearbyChlorophyte(int i, int j) {
 			float num = 0f;
 			int num2 = 5;
 			if (i <= num2 + 5 || i >= Main.maxTilesX - num2 - 5)
@@ -45512,7 +_,7 @@
 			}
 		}
 
-		private static int MossConversion(int thisType, int otherType) {
+		public static int MossConversion(int thisType, int otherType) {
 			if (TileID.Sets.tileMossBrick[thisType] && otherType == 38)
 				return thisType;
 
@@ -45565,6 +_,8 @@
 			if (gen)
 				return;
 
+			WorldHooks.PreUpdate();
+
 			AllowedToSpreadInfections = true;
 			CreativePowers.StopBiomeSpreadPower power = CreativePowerManager.Instance.GetPower<CreativePowers.StopBiomeSpreadPower>();
 			if (power != null && power.GetIsUnlocked())
@@ -45642,7 +_,7 @@
 				return;
 
 			for (int l = 0; l < Main.dayRate; l++) {
-				float num6 = Main.maxTilesX / 4200;
+				float num6 = Main.maxTilesX / 4200f; // Selfish fix for falling stars on extra small worlds
 				num6 *= Star.starfallBoost;
 				if (!((float)Main.rand.Next(8000) < 10f * num6))
 					continue;
@@ -45673,6 +_,7 @@
 					Projectile.NewProjectile(position.X, position.Y, num13, num14, 720, 0, 0f, Main.myPlayer, 0f, num10);
 				}
 			}
+			WorldHooks.PostUpdate();
 		}
 
 		public static int GetWorldUpdateRate() {
@@ -45683,7 +_,8 @@
 			return result;
 		}
 
-		private static void UpdateWorld_OvergroundTile(int i, int j, bool checkNPCSpawns, int wallDist) {
+		public static void UpdateWorld_OvergroundTile(int i, int j, bool checkNPCSpawns, int wallDist) {
+			WallLoader.RandomUpdate(i,j,Main.tile[i,j].wall);
 			int num = i - 1;
 			int num2 = i + 2;
 			int num3 = j - 1;
@@ -46251,7 +_,8 @@
 			}
 		}
 
-		private static void UpdateWorld_UndergroundTile(int i, int j, bool checkNPCSpawns, int wallDist) {
+		public static void UpdateWorld_UndergroundTile(int i, int j, bool checkNPCSpawns, int wallDist) {
+			TileLoader.RandomUpdate(i,j,Main.tile[i,j].type);
 			int num = i - 1;
 			int num2 = i + 2;
 			int num3 = j - 1;
@@ -46785,7 +_,7 @@
 			}
 		}
 
-		private static void UpdateWorld_GrassGrowth(int i, int j, int minI, int maxI, int minJ, int maxJ, bool underground) {
+		public static void UpdateWorld_GrassGrowth(int i, int j, int minI, int maxI, int minJ, int maxJ, bool underground) {
 			if (underground) {
 				int type = Main.tile[i, j].type;
 				int num = -1;
@@ -47136,7 +_,7 @@
 			}
 		}
 
-		private static void TrySpawningTownNPC(int x, int y) {
+		public static void TrySpawningTownNPC(int x, int y) {
 			bool flag = Main.tileSolid[379];
 			Main.tileSolid[379] = true;
 			if (prioritizedTownNPCType > 0) {
@@ -48233,7 +_,7 @@
 			}
 		}
 
-		private static bool badOceanCaveTiles(int x, int y) {
+		public static bool badOceanCaveTiles(int x, int y) {
 			if (Main.tile[x, y].wall == 83 || Main.tile[x, y].wall == 3 || Main.wallDungeon[Main.tile[x, y].wall] || Main.tile[x, y].type == 203 || Main.tile[x, y].type == 25 || Main.tileDungeon[Main.tile[x, y].type] || Main.tile[x, y].type == 26 || Main.tile[x, y].type == 31)
 				return true;
 
@@ -51318,6 +_,8 @@
 							return false;
 					}
 					if (Main.tile[x, y - 1].active()) {
+						if (TileID.Sets.BasicChest[Main.tile[x, y - 1].type])
+							return false;
 						switch (Main.tile[x, y - 1].type) {
 							case 21:
 							case 26:
@@ -51481,6 +_,7 @@
 
 		public static bool UpdateMapTile(int i, int j, bool addToList = true) {
 			bool result = false;
+#if CLIENT
 			if (Main.mapEnabled && !noMapUpdate && !gen && Main.Map[i, j].Light > 0 && Main.Map.UpdateType(i, j) && addToList) {
 				result = true;
 				if (MapHelper.numUpdateTile < MapHelper.maxUpdateTile - 1) {
@@ -51492,6 +_,7 @@
 					Main.refreshMap = true;
 				}
 			}
+#endif
 
 			return result;
 		}
@@ -51766,7 +_,10 @@
 						Liquid.AddWater(i, j);
 
 					if (tile.active()) {
-						if (noBreak && Main.tileFrameImportant[tile.type] && tile.type != 4)
+						if (!TileLoader.TileFrame(i, j, tile.type, ref resetFrame, ref noBreak))
+							return;
+
+						if (noBreak && Main.tileFrameImportant[tile.type] && !TileID.Sets.Torch[tile.type])
 							return;
 
 						int num = tile.type;
@@ -51790,7 +_,7 @@
 								case 571:
 									CheckBamboo(i, j);
 									break;
-								case 4:
+								case int _ when TileID.Sets.Torch[num]:
 									CheckTorch(i, j);
 									break;
 								case 442:
@@ -52290,7 +_,7 @@
 															if (num != 354 && num != 406 && num != 412 && num != 355 && num != 452 && num != 455 && num != 491 && num != 499) {
 																switch (num) {
 																	case 15:
-																	case 20:
+																	case int _ when TileID.Sets.TreeSapling[num]:
 																	case 216:
 																	case 338:
 																	case 390:
@@ -52359,7 +_,7 @@
 																				CheckOnTable1x1(i, j, num);
 																				return;
 																			default:
-																				if (TileID.Sets.BasicChest[num]) {
+																				if (TileID.Sets.BasicChest[num] && num < TileID.Count) {
 																					CheckChest(i, j, num);
 																					return;
 																				}
@@ -52617,6 +_,7 @@
 																														CheckGnome(i, j);
 																														break;
 																												}
+																												TileLoader.CheckModTile(i, j, num); // TODO: Test this. Not sure this is still correct.
 
 																												return;
 																											}
@@ -52820,13 +_,10 @@
 										}
 
 										switch (num) {
-											case 147:
+											case int _ when TileID.Sets.Snow[num]:
 												TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Ices, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 												break;
-											case 161:
-											case 163:
-											case 164:
-											case 200:
+											case int _ when TileID.Sets.Ices[num]:
 												TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Snow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 												break;
 											case 162:
@@ -52834,7 +_,7 @@
 												break;
 											default:
 												if (Main.tileBrick[num]) {
-													if (num == 60 || num == 70)
+													if (TileID.Sets.GrassSpecial[num])
 														TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													else
 														TileMergeAttempt(num, Main.tileBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
@@ -52845,14 +_,14 @@
 												break;
 										}
 
-										if ((num == 1 || Main.tileMoss[num] || num == 117 || num == 25 || num == 203) && down == 165) {
+										if ((TileID.Sets.Stone[num] || Main.tileMoss[num]) && down == 165) {
 											if (tile9.frameY == 72)
 												down = num;
 											else if (tile9.frameY == 0)
 												down = num;
 										}
 
-										if ((num == 1 || Main.tileMoss[num] || num == 117 || num == 25 || num == 203) && up == 165) {
+										if ((TileID.Sets.Stone[num] || Main.tileMoss[num]) && up == 165) {
 											if (tile8.frameY == 90)
 												up = num;
 											else if (tile8.frameY == 54)
@@ -52867,7 +_,7 @@
 												up = num;
 										}
 
-										if ((num == 200 || num == 161 || num == 147 || num == 163 || num == 164) && down == 165)
+										if ((TileID.Sets.Ices[num] || num == 147) && down == 165)
 											down = num;
 
 										if ((tile.slope() == 1 || tile.slope() == 2) && down > -1 && !TileID.Sets.Platforms[down])
@@ -53021,7 +_,7 @@
 														if (mergeDown)
 															up = num;
 													}
-													else if (up == 147) {
+													else if (up >= 0 && TileID.Sets.Snow[up]) {
 														TileFrame(i, j - 1);
 														if (mergeDown)
 															up = num;
@@ -53032,7 +_,7 @@
 														if (mergeUp)
 															down = num;
 													}
-													else if (down == 147) {
+													else if (down >= 0 && TileID.Sets.Snow[down]) {
 														TileFrame(i, j + 1);
 														if (mergeUp)
 															down = num;
@@ -53043,7 +_,7 @@
 														if (mergeRight)
 															left = num;
 													}
-													else if (left == 147) {
+													else if (left >= 0 && TileID.Sets.Snow[left]) {
 														TileFrame(i - 1, j);
 														if (mergeRight)
 															left = num;
@@ -53163,16 +_,14 @@
 										}
 										else {
 											switch (num) {
-												case 58:
-												case 75:
-												case 76:
+												case int _ when TileID.Sets.HellSpecial[num]:
 													TileMergeAttempt(-2, 57, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													break;
 												case 57:
 													TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													TileMergeAttemptFrametest(i, j, num, TileID.Sets.HellSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													break;
-												case 59:
+												case int _ when TileID.Sets.Mud[num]:
 													if ((double)j > Main.rockLayer)
 														TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													TileMergeAttempt(num, TileID.Sets.GrassSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
@@ -53204,14 +_,10 @@
 													TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													TileMergeAttempt(num, 196, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													break;
-												case 147:
+												case int _ when TileID.Sets.Snow[num]:
 													TileMergeAttemptFrametest(i, j, num, TileID.Sets.IcesSlush, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													break;
-												case 161:
-												case 163:
-												case 164:
-												case 200:
-												case 224:
+												case int _ when TileID.Sets.IcesSlush[num]:
 													TileMergeAttempt(-2, 147, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													break;
 												case 162:
@@ -53314,11 +_,11 @@
 											TileMergeAttempt(num, 59, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 
 										bool flag = false;
-										if (num == 2 || num == 23 || num == 60 || num == 477 || num == 492 || num == 70 || num == 109 || num == 199 || Main.tileMoss[num] || TileID.Sets.NeedsGrassFraming[num] || TileID.Sets.tileMossBrick[num]) {
+										if (TileID.Sets.Grass[num] || TileID.Sets.GrassSpecial[num] || Main.tileMoss[num] || TileID.Sets.NeedsGrassFraming[num] || TileID.Sets.tileMossBrick[num]) {
 											flag = true;
 											TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 											int num32 = TileID.Sets.NeedsGrassFramingDirt[num];
-											if (num == 60 || num == 70) {
+											if (TileID.Sets.GrassSpecial[num]) {
 												num32 = 59;
 											}
 											else if (Main.tileMoss[num]) {
@@ -54749,7 +_,7 @@
 												}
 											}
 											else {
-												if (num != 2 && num != 23 && num != 60 && num != 70 && num != 109 && num != 199 && num != 477 && num != 492) {
+												if (!TileID.Sets.Grass[num] && !TileID.Sets.GrassSpecial[num]) {
 													if (up == -1 && down == -2 && left == num && right == num) {
 														switch (num27) {
 															case 0:
@@ -55298,7 +_,7 @@
 												TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 											}
 
-											if (num == 2 || num == 23 || num == 60 || num == 70 || num == 109 || num == 199 || num == 477 || num == 492 || Main.tileMoss[num] || TileID.Sets.tileMossBrick[num])
+											if (TileID.Sets.Grass[num] || TileID.Sets.GrassSpecial[num] || Main.tileMoss[num] || TileID.Sets.tileMossBrick[num])
 												TileMergeAttempt(num, -2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 
 											if (up == num && down == num && left == num && right == num) {
@@ -55887,7 +_,7 @@
 			}
 		}
 
-		private static void CheckProjectilePressurePad_GetPossiblePlacementDirections(int i, int j, out bool canUp, out bool canLeft, out bool canRight, out bool canDown) {
+		public static void CheckProjectilePressurePad_GetPossiblePlacementDirections(int i, int j, out bool canUp, out bool canLeft, out bool canRight, out bool canDown) {
 			canUp = false;
 			canLeft = false;
 			canRight = false;
@@ -55980,7 +_,7 @@
 			return style;
 		}
 
-		private static void CheckDoorOpen(int i, int j, Tile tileCache) {
+		public static void CheckDoorOpen(int i, int j, Tile tileCache) {
 			if (destroyObject)
 				return;
 
@@ -56055,7 +_,7 @@
 			destroyObject = false;
 		}
 
-		private static void CheckDoorClosed(int i, int j, Tile tileCache, int type) {
+		public static void CheckDoorClosed(int i, int j, Tile tileCache, int type) {
 			if (!destroyObject) {
 				int num = j;
 				bool flag = false;
@@ -56120,7 +_,7 @@
 			}
 		}
 
-		private static void GetSandfallProjData(int type, out int projType, out int dmg) {
+		public static void GetSandfallProjData(int type, out int projType, out int dmg) {
 			dmg = 10;
 			switch (type) {
 				case 112:
@@ -56181,7 +_,7 @@
 
 		public static bool AllowsSandfall(Tile tileTopCache) {
 			bool result = true;
-			if (tileTopCache.active() && (TileID.Sets.BasicChest[tileTopCache.type] || TileID.Sets.BasicChestFake[tileTopCache.type] || tileTopCache.type == 323 || tileTopCache.type == 88 || tileTopCache.type == 80 || tileTopCache.type == 77 || tileTopCache.type == 26 || tileTopCache.type == 475 || tileTopCache.type == 470 || tileTopCache.type == 597))
+			if (tileTopCache.active() && (TileID.Sets.BasicChest[tileTopCache.type] || TileID.Sets.BasicChestFake[tileTopCache.type] || tileTopCache.type == 323 || TileID.Sets.BasicDresser[tileTopCache.type] || tileTopCache.type == 80 || tileTopCache.type == 77 || tileTopCache.type == 26 || tileTopCache.type == 475 || tileTopCache.type == 470 || tileTopCache.type == 597))
 				result = false;
 
 			return result;
